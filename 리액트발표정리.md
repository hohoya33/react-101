### React?
사용자 인터페이스를 만드는 자바스크립트 라이브러리
컴포넌트를 통한 View표현만 담당

Facebook이 만들고 있는 이른바 MVC 프레임워크에서의 뷰(View) 부분을 컴포넌트로 만들기위한 라이브러리입니다.
React는 Facebook에서 개발해 Facebook과 Instagram, Airbnb 등에서 사용하고 있는

사용자 액션에 따라 DOM을 일일이 다루었던 과거 개발 방식(jQuery와 같은 라이브러리만을 사용하는)과는 달리 
개발자가 DOM을 직접 다루지 않고 React가 데이터 상태에 따라 자동으로 UI를 관리하기 때문에, 개발자는 단순히 특정 상태에 대한 뷰의 변화만 구현하면 된다.

React 특징

UI 컴포넌트를 만들기 위한 라이브러리이며 React의 컴포넌트는 트리형태로 구성된다.
Virtual DOM을 사용하여 변경된 부분에 대한 최소한의 DOM 처리로 UI를 업데이트하여 애플리케이션의 성능을 향상한다.
부모 컴포넌트에서 하위 컴포넌트로 전달하는 단방향의 단순한 데이터 흐름을 갖고 있어 데이터 추적과 디버깅을 쉽게 해준다.

### React 특징
* 리액트가 왜 전세계적으로 열광하고 인기있는지??
* 자바스크립트 기반, 별도로 다른 프레임워크를 배울필요없음 그냥 자바스크립트를 활용
* 리액트를 하면서 동시에 자바스크립트 기술 향상
* 리액트 구조는 요소별, 컴포넌트별로 나눠서 작업을 할 수있게 되어 있음
Composition 자세히 뜯어보면
<Nav />
<Header />
<Number />
<Grid />
요소들로 볼 수 있음
그룹별료 쪼개서 작업을 할 수 있음
모든걸 작은 요소 (components)로 쪼개서 작업, 마무리하면 가져다가 다른 곳에 쓸 수있음 

* JSX
리액트로 html을 쓰는 방법

* 단방향 데이터플로우 Unidirectional
데이터는 항상 일정한 장소에 위치해있고, 그 장소에서만 변경 할 수 있음
리액트의 경우 데이터는 위치한 장소에 있고 
상태가 변했을 경우 데이터는 그대로 있고, UI가 업데이트 됨


데이터가 변하면 UI가 업데이트됨
데이티가 안변하면, UI도 안변하겠지
데이터가 변하면 UI는 새로운 데이터와 함께 업데이트 됨
즉 UI에서는 데이터를 바꿀 수는 없어
항상 같은 방향 데이터 -> 데이터 변경 -> UI변경


### 설치
https://github.com/facebookincubator/create-react-app 

```bash
npm install -g create-react-app
```

### Creating an App
```bash
create-react-app ssg-app
cd ssg-app

npm start
```




# 01. Creating React Components with JSX
* React와 ReactDOM의 차이
React는 UI 라이브러리

ReactDOM은 React를 웹사이트에 출력(render)하는 걸 도와주는 모델
* React를 웹사이트에 올려놓고 싶다 그럴때는 ReactDOM 사용
* React를 모바일앱에 올려놓고 싶다 그럴때는 React Native 사용

리액트돔은 1개의 컴포넌트를 출력(render)하고
도큐먼트안에 엘리먼트가 있는데 엘리먼트 ID는 root, index.html 파일안에 있음
렌더를 하면 모든 컴포넌트들이 여기로 출력됨

우리가 만들기 시작할 컴포넌트는 App, 여기에 모든 상품 정보를 넣음, 지금은 텅텅비워 있음

새로운 컴포넌트를 만들자 new file Product.js, Product.css
App.js처럼 사용 동일하기 작성
class Product..작성
컴포넌트는 항상 render를 해야함
export를 작성해서 App.js로 해당 컴포넌트를 내보냄

이렇게 작성된 Product 컴포넌트를 App컴포넌트 안에다가 레고조각모음 하는거 마냥 
집어넣으면 됨

컴포넌트 생성 -> 렌더 -> 리턴 -> html내용 -> 브라우저에서 확인

Product 컴포넌트를 App.js에서 여러번 불러올 수도 있음
Product 컴포넌트 안에 실제 상품 정보를 작성 상품이미지를 넣어보자
클래스명은 ProductImage renter > return > 이미지소스

보시다시피 큰 컴포넌트 안에 작은 컴포넌트를 집어넣는 방식으로 작업을 함
그리고 Product 컴포넌트안에 상품명, 정보 등 또다른 작은 컴포넌트들이 있음
컴포넌트를 만들었으니 이제 컴포넌트를 아름답게 만들고 데이터랑 연동하고 리스트에 출력

또하나 염두해야할 것
여기에 React와 같은 변수를 참조하지 않았음에도 여전히 이것을 불러오는것이 필요합니다. import React from 'react'

모듈을 export할때 이렇게 상단에 선언하는 이유는
JSX를 평범한 자바스크립트로 변환할때마다 이는 React.createElement와 같은 형태로 변환되기 때문
그리고 리액트가 이범위안에 없으면 이를 지나쳐버릴 것입니다.
그래서 리액트를 JSX를 가지는 모든 컴포넌트에 임폴트하는 것을 확인


```js
//App.js
import React, { Component } from 'react';
import Product from './Product';

class App extends Component {
  render() {
    return (
      <div className="App">
        <Product />
        <Product />
        <Product />
      </div>
    );
  }
}
export default App;
```

```js
//Product.js
import React, { Component } from 'react';

class Product extends Component {
    render() {
        return (
            <div>
                <ProductImage />
                <h1>상품명 상품명 상품명</h1>
            </div>
        );
    }
}
class ProductImage extends Component {
    render() {
        return (
            <img src="http://item.ssgcdn.com/32/08/58/item/1000024580832_i1_500.jpg" />
        );
    }
}
export default Product;
```








# 02. Data flow with Props
리액트에는 2개의 주요컨셉, 하나는 state 나머지 하나는 props

App.js에서 모든 상품을 가져옴(메인 컴포넌트에 상품 리스트가 있음)
그리고 그 리스트안에 해당 상품 정보가 담김
즉, 부모컴포넌트는 자식 컴포넌트에 각각 정보를 전달함
상품 이름을 적고 각각의 상품에 다른 이름을 부여함

```js
//App.js
const itemName = [
  '[LG]LG전자 트롬 RH9SA, RH9WA 인버터 전기식 건조기 용량9KG',
  '[일룸(iloom)]사랑받는 이유, 일룸이 제안하는 홈스타일링',
  '[발뮤다]에어엔진(그레이/ 블랙 로그인시 추가쿠폰지원(일부상품제외)'
];

const itemImages = [
  'http://item.ssgcdn.com/16/88/15/item/1000021158816_i1_202.jpg',
  'http://item.ssgcdn.com/25/08/15/item/1000023150825_i1_202.jpg',
  'http://item.ssgcdn.com/15/01/48/item/1000017480115_i1_202.jpg'
];

class App extends Component {
  render() {
    return (
      <div className="App">
        <Product name={itemName[0]} image={itemImages[0]} />
        <Product name={itemName[1]} image={itemImages[1]} />
        <Product name={itemName[2]} image={itemImages[2]} />
      </div>
    );
  }
}

//Product.js
class Product extends Component {
    render() {
        console.log(this.props);
        return (
            <div>
                <ProductImage image={this.props.image} />
                <h1>{this.props.name}</h1>
            </div>
        );
    }
}

class ProductImage extends Component {
    render() {
        return (
            <img src={this.props.image} />
        );
    }
}
```
그리고 Product 컴포넌트에서 각 상품 이름은 props를 통해 받음. 각 요소들을 액세스하는 방법{this.props.title}
이렇게 부모 컴포넌트가 자식컴포넌트에 정보를 주는 것
JSX의 경우 명령을 실행시키려면 괄호{}를 꼭 사용해야함

부모 컴포넌트는 이제 상품이름, 이미지를 자식 컴포넌트(Product)에게 줄거야
Product 컴포넌트에서 상품 이미지만 ProductImage 에게 줄꺼야 

데이터 소스는 한군데 메인 컴포넌트가 데이터를 다 가지고 있음
상품이름, 이미지 정보를 메인에다가 다 집어넣고 그걸 각각 컴포넌트에 props를 이용해 정보를 출력
이를 이용해 강력한 UI를 구축 할 수 있음






# 03. Lists with map
영화정보를 토대로 리스트 제작
이전에 만든 리스트는 효율적이지 않음, 계속 복사붙여넣기 할 수 없음 
API에서 끍어온 엄청난 양의 영화정보를 불러오고 싶을 때
이를 위해 배열 생성
이 리스트에는 여러 오브젝트가 있음 


다음에 해야할 것은 반복자인 루프를 만드는 것입니다.
이는 자바스크립트의 for루프를 의미하는것이 아닌데요
일반적으로 가능하면 for 루프로 부터 떨어져 있기를 충고해드림
대신에 map과 같은 이터레이터를 사용하길 권합니다.
이 map를 사용하지 않더라도 문제는 없지요. 자바스크립트 구문을 쓴다면 배열을 반복하기 위해 배열을 선언하고
for문을 이용해 배열을 루핑하지요. 이와같은 방식은 때때로 헷갈리고 타이핑 시에 실수도 발생하는데요
대신에 빌드인 헬퍼인 map를 사용할 것입니다.
map는 배열의 프로퍼티구요, map은 함수를 반환합니다. 이 map을 통해 새로운 배열이 반환, 각 값들은 이 함수를 통해서 새로 반환
그래서 이 map을 사용하는 것은 리액트에서 리스트를 만들기 위한 매우 편리한 방법


JavaScript - map
"map() 메소드는 파라미터로 전달 된 함수를 통하여 배열 내의 각 요소를 처리해서 그 결과로 새로운 배열을 생성합니다."
```js
//App.js
const items = [
  {
    name: '[LG]LG전자 트롬 RH9SA, RH9WA 인버터 전기식 건조기 용량9KG',
    image: 'http://item.ssgcdn.com/16/88/15/item/1000021158816_i1_202.jpg'
  },
  {
    name: '[일룸(iloom)]사랑받는 이유, 일룸이 제안하는 홈스타일링',
    image: 'http://item.ssgcdn.com/25/08/15/item/1000023150825_i1_202.jpg',
  },
  {
    name: '[발뮤다]에어엔진(그레이/ 블랙 로그인시 추가쿠폰지원(일부상품제외)',
    image: 'http://item.ssgcdn.com/15/01/48/item/1000017480115_i1_202.jpg'
  },
];
```
array들은 map이라는 기능을 사용할 수 있음
map은 새로운 배열을 만듬
```js
//App.js
class App extends Component {
  render() {
    return (
      <div className="App">
        {items.map(item => {
          return <Product name={item.name} image={item.image} />
        })}
      </div>
    );
  }
}
```
이렇게 리스트를 만듬. 배열 하나를 잡고 매핑(map)해서 하나의 컴포넌트를 만듬

console에서 확인한 에러
Each child in an array or iterator should have a unique "key" prop.
리액트의 경우 엘리먼트가 많을 경우 key값을 줘야함. 이 key는 고유해야함
각 리스트 아이템에 키를 넣어서 리액트가 빠른 방법으로 적적한 레코드를 업데이트 할 수 있음


특별한 키 props를 가져야 한다는 것인데
리액트는 리스트를 렌더링 하는것이 매우 유능한데 어찌보면 약간 과하게 유능합니다.
배열 아이템을 렌더링 할 때 마다 리액트는 리스트를 만드는 것이라 가정합니다.
명백하게 이는 배열이고 리액트는 리스트를 렌더링하는 프로세스를 최대한 최적화 하여 만들것입니다.
당신이 큰 무더기의 노트카드를 가지고 있다고 생각해 보세요 그리고 그것들은 각각 매우 중요한 정보가 업데이트 되거나 프린트 된다고 합시다 

만약 각 카드에 아이디가 있다면 사람들이 여러분에게 하나를 콕집어서 말하기를 아이디 5카드를 업데이트해줘 라고 말하면 프로세스가 훨씬 빨라지죠 

리스트를 만들면서 특별한 요소를 위한 ID를 가지고 있으면 요소가 바뀔때 어떤 요소인지 알아채고 업데이트가 필요한 것이죠
그렇지 않으면 모든것을 버리고 다시 재생성해야 하죠 이 리스트를 위한 키는 무척 명료합니다.


```js
//App.js
<div className="App">
    {items.map((item, index) => {
        return <Product name={item.name} image={item.image} key={index} />
    })}
</div>
```

# 04. Validating Props with Prop Types
포스터에 출력되는 값이 숫자나, true/false 같은 값들이 들어오길 원치 않을 때
이걸 확인하는 방법은?
그리고 여기에 2가지 타입을 원한다고 정의, 하나는 타이틀, 나머지는 포스터
타이틀의 경우 리액트 프로퍼티타입은 string
포스터의 경우 위와 동일하게 작성
```js
static propTypes = {
    title: React.PropTypes.string,
    poster: React.PropTypes.string
}
```
React에서 PropTypes deprecated 해결하기
Line 6:  React.PropTypes is deprecated since React 15.5.0, use the npm module prop-types instead  react/no-deprecated

살펴보니, React (15.5.0)에서부터는 React의 main package에 PropTypes가 제거되고, 별도의 라이브러리를 사용하는 식으로 변경되었다.

해결방법

React의 prop-types library 을 설치하기
npm 주소: https://www.npmjs.com/package/prop-types
기존에 React.PropTypes.<typeName> 으로 작성하던 부분을 PropTypes.<typeName> 형태로 작성하면 된다.

```bsh
$ npm install --save prop-types
```
```js
//Product.js
//npm으로 설치 후, 아래와 같이 'prop-types'을 새로 import 
import PropTypes from 'prop-types';

class Product extends Component {
    static propTypes = {
        name: PropTypes.string.isRequired,
        image: PropTypes.string.isRequired
    }

    render() {
        console.log(this.props);
        return (
            <div>
                <ProductImage image={this.props.image} />
                <h1>{this.props.name}</h1>
            </div>
        );
    }
}
class ProductImage extends Component {
    static propTypes = {
        image: PropTypes.string.isRequired
    }

    render() {
        return (
            <img src={this.props.image} />
        );
    }
}
```
만약 타이틀이 숫자여야 한다고 지정하면 어떻게 될까?
title: PropTypes.number
에러 출력
우리가 얻게되는 정보가 숫자가 아니라는 것을 체크 할 수 있음
만약 부모 컴포넌트에서 string을 보내면 PropTypes으로 string이라는것을 체크할 수 있다
덕분에 부모 컴포넌트에서 받는 데이터 타입이 무엇인지 체크 할 수 있다

'isRequired'라고 작성하면 movie 컴포넌트는 title이라는 prop을 제공하는 것이 필수로 설정
title: PropTypes.number.isRequired
이 상태에서 타이틀을 삭제하면 어떻게 될까
에러 출력 require필수 조건인 prop이 없다고 알림
필수요건이라고 지정해서 만약 데이터가 없을 경우 에러 메세지를 받을 수 있음
API를 통해 정보를 불러올 때 
```js
import PropTypes from 'prop-types';

class TestComponent extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            <div>
                <div className='test-title'>
                    {this.props.label}
                </div>
                <div className='test-contents'>
                    {this.props.contents}
                </div>
            </div>
        );
    }
}
TestComponent.propTypes = {
    label: PropTypes.string,
    contents: PropTypes.element
};
```



# 05. Component Lifecycle
* 리액트 라이프사이클?
컴포넌트는 여러기능을 정해진 순서대로 실행

* Render: componentWillMount() -> render() -> componentDidMount()
이 사이클은 자동으로 발생
콘솔로그 테스트해보자!

컴포넌트가 존재하기 시작하면 리액트는 will mount -> render -> did mount 실행
예를 들면 영화앱같은 어플리케이션을 만들 때 will mount를 진행할때 api작업을 요청
해당 작업 수행이 완료되면 그 다음 데이터 관련 작업 진행
```js
class App extends Component {
  //Render: componentWillMount() -> render() -> componentDidMount()
  //Update: componentWillReceiveProps() -> shouldComponetUpdate() -> componentWillUpdate() -> render() -> componentDidUpdate()
  componentWillMount() {
    console.log('(1) will mount');
  }

  componentDidMount() {
    console.log('(3) did mount');
  }

  render() {
    console.log('(2) render');
    return (
      <div className="App">
        {items.map((item, index) => {
          return <Product name={item.name} image={item.image} key={index} />
        })}
      </div>
    );
  }
}
```
업데이트의 경우?
* Update: componentWillReceiveProps() -> shouldComponetUpdate() -> componentWillUpdate() -> render() -> componentDidUpdate()

componentWillReceiveProps()
컴포넌트가 새로운 props을 받았다는 뜻

shouldComponetUpdate()
리액트는 이전 props이,  새로운 props들과 다르면 업데이트가 발생
그다음 컴포넌트가 업데이트 할거라는 단계로 넘어감

componentWillUpdate()

render()

마지막으로
componentDidUpdate()

렌더를 하거나 업데이트를 할 때 항상 이와 같은 순서로 작동
이를 이해하면 나중에 컴포넌트를 빌드할 때 도움이 됨
예를 들면 componentWillUpdate를 수행 할 때 어플리케이션에 빙글빙글 돌아가는 스피너를 붙일 수 있겠지
업데이트 이 후 componentDidUpdate 에서 돌고있던 로딩중 메세지나 아이콘을 숨김 처리하면 될거야 
컴포넌트 업데이트가 완료 되었으니깐
기억해야할것은 컴포넌트는 많은 function을 갖고 있고 그들은 순서대로 자동으로 실행, 이것을 막을 수는 없음
라이프 사이클의 세부 내용은 실전에서 바로 해보면서 배우도록 하자

# 06. Thinking in React Component State
이번에는 state를 알아보자

스테이트가 바뀔때마다 즉시 리렌더링이 되고 이 컴포넌트를 가지는 자식에게도 영향을 미칩니다.

state는 리액트 컴포넌트 안에 있는 오브젝트
유저 이벤트를 저장하고 반응하는데 이용
우리가 정의한 컴포넌트 기반의 각 클래스는 그 자체의 스테이트 객체를 가집니다.
컴포넌트 스테이트가 바뀔때마다 컴포넌트는 즉시 렌더링하고 자식요소들에게도 렌더링하도록 강제
이 스테이트를 사용하기 전에 스테이트 객체를 초기화


스테이트 프로퍼트를 클래스의 constructor메소드 안에 넣음 
스테이트를 정의하거나 재초기화하는 방법
이때 함수형 컴포넌트는 스테이트를 가지지 않음. 오직 클래스기반 컴포넌트만 가능

모든 자바스크립트의 클래스는 특별한 함수인 constructor가 있음
이 함수는 첫번째로 시작되고 클래스가 생성될때마다 자동으로 실행 새 인스턴스가 생성될때마다 불러지기 때문

constructor함수는 이 클래스 안에서 뭔가를 설정하는데 활용
변수나 상태값을 초기화하는 등에 주로 이용

여기서 super(props)라는 함수 
이 검색바 컴포넌트가 리액트 Component를 상속받는데요
이 Component에는 constructor함수를 가집니다.
부모 클래스에 메소드를 미리 정의 했을때 super를 호출하면서 이 부모 클래스의 메소드를 호출 할 수있습니다.
만약 잘 모르시더라도 걱정하진 마세요 일단 일종에 마법같은거라고 생각하면 됩니다.

오직 constructor함수 안에서만 this.state = { term: '' } 이런코드로 스테이트를 변화 할 수있습니다.
이 값은 다른 컴포넌트 안에서는 항상 this.setState({ term: event.target.value })를 사용

this.state.term = event.target.value 같은 식으로는 절대 변경되지 않습니다. 이런 구문은 절대 쓰지 마세요!!

이 this.setState로만 값 조정이 가능한데요 setState는 지속적으로 유지가 되게 하며
리액트 백단에서 이 스테이트를 위한 많은 여러가지를 하고 있습니다. 만약 이 값을 바꾼다면 리액트는 이 값이 바뀐지 잘 모를텐데요
이를 이 메소드(this.setState)로 리액트에 알리게 되죠
저기요 스테이트가 변했고 여기 새로운 스테이트가 있습니다. 라는 식으로요

JSX안에서 자바스크립트 변수를 참조할때는 {} 중괄호로 이를 감싸줍니다.
여기에 {this.state.term} 작성
이렇게 this.state.term과 같이 작성했지만 이는 term값을 수정하는 것이 아니라 참조하기 위한 조치입니다. 여기에 이런값이 있다고 이야기 해주는 것이죠
이 스테이트값에 4나 5같은 값을 직접 대입 하시면 안됩니다. {this.state.term = '4'} //BAD!!


우리가 인풋요소를 업데이트하거나 값을 변화시킬때마다 change이벤트가 발생, 우리는 스테이트를 세팅하고 this.state.term은 인풋의 새 값을 가지게 됨

스테이트가 업데이트 되거나 this.setState가 호출될때 이는 컴포넌트에 자동적으로 렌더링 신호를 보내고
이 렌더링 메소드의 모든 업데이트된 정보를 DOM에 푸쉬합니다. 왜냐하면 render메소드는 this.state.term을 참조하기 시작하고
컴포넌트가 리렌더링 될때마다 DOM안의 this.state.term이 업데이트 되는 것입니다.
이것이 스테이트의 작동방식이구요


규칙은 다음과 같다
컴포넌트 안에 state가 바뀔때 마다 render()가 발생
첫번째 state를 만드는 방법은
```js
state = {
    greeting: 'Hello'
}

<div className="App">
    {this.state.greeting}
</div>
```

위와 같이 작성하고


컴포넌트가 mount되면 5초 기다리고 greeting을 업데이트
지금 작성하는것처럼 써서 greeting를 업데이트 하지 않아
state를 직접적으로 쓰면 안됨

```js
setTimeout(() => {
    this.state.greeting = 'someting';
}, 5000)
```
콘솔창 확인 직접적으로 state를 변경하지 말라라고 경고 표시
//Render: componentWillMount() -> render() -> componentDidMount()
직접적으로 변경하면 위의 render 함수들이 작동을 안함
state를 업데이트 하려면 this.setState를 사용해야 함


여기서 새로운 state를 만들어야 해
```js
this.setState({
    greeting: 'Hello again!'
});
```
이 뜻은 컴포넌트가 마운트 할 때 마다 greeting을 hello -> hello again으로 변경 한다는 뜻
render()가 다시 동작해서 변경 됨
저장 새로고침 확인 hello, 그리고 5초 후에 hello again!!
차이점은 greeting렌더링을 setState에서 하는 거야
state를 변경할 수 있고 자동으로 render()가 작동되는 거지
state를 바꿀때는 setState를 설정하고, 
state를 변경하면 render()가 다시 작동한다 새로운 state와 함께

```js
class App extends Component {
  //Render: componentWillMount() -> render() -> componentDidMount()
  //Update: componentWillReceiveProps() -> shouldComponetUpdate() -> componentWillUpdate() -> render() -> componentDidUpdate()
  state = {
    greeting: 'Hello'
  }

  componentWillMount() {
    console.log('(1) will mount');
  }

  componentDidMount() {
    console.log('(3) did mount');
    setTimeout(() => {
      this.setState({
        greeting: 'Hello again!'
      });
    }, 5000)
  }

  render() {
    console.log('(2) render');
    return (
      <div className="App">
        {this.state.greeting}

        {items.map((item, index) => {
          return <Product name={item.name} image={item.image} key={index} />
        })}
      </div>
    );
  }
}
```

# 07. Practicing this setState
state를 좀 더 연습해보자
컴포넌트 외부에 있는 상품 리스트를 컴포넌트 state 안으로 옮겨보자
기존 상품리스트를 잘라서 state로 붙여넣음

그리고 저장하면 'items' is not defined 정의되어 있지 않았다고 에러뜸
```js
  state = {
    items: [
      {
        name: '[LG]LG전자 트롬 RH9SA, RH9WA 인버터 전기식 건조기 용량9KG',
        image: 'http://item.ssgcdn.com/16/88/15/item/1000021158816_i1_202.jpg'
      },
      {
        name: '[일룸(iloom)]사랑받는 이유, 일룸이 제안하는 홈스타일링',
        image: 'http://item.ssgcdn.com/25/08/15/item/1000023150825_i1_202.jpg',
      },
      {
        name: '[발뮤다]에어엔진(그레이/ 블랙 로그인시 추가쿠폰지원(일부상품제외)',
        image: 'http://item.ssgcdn.com/15/01/48/item/1000017480115_i1_202.jpg'
      }
    ]
  }
//그래서 items에 this.state를 앞에 붙여주자
    <div className="App">
        {this.state.items.map((item, index) => {
            return <Product name={item.name} image={item.image} key={index} />
        })}
    </div>
```
여기 상품 리스트에서 상품을 하나 더 추가 하고싶으면 어떻게 할까?
이제 상품을 리스트에 추가 해보자

setState 안에서 상품을 추가 하고 싶다고 써야해. 어떻게 하느냐 (items array에 추가)
this.setState와 같이 작성하고
새로고침 후 확인해보면 새로운 상품이 추가된것이 보입니다. 자세히 살펴보면

컴포넌트가 mount하면 페이지로드 후 1초후에 추가한 새로운 상품이 보여짐

```js
  componentDidMount() {
    console.log('(3) did mount');
    setTimeout(() => {
      this.setState({
        items: [
          ...this.state.items,
          {
            name: '[입생로랑(YSL)]2017 홀리데이 컴플리트 메이크업 팔레트',
            image: 'http://item.ssgcdn.com/27/52/13/item/1000024135227_i1_202.jpg'
          }
        ]
      });
    }, 1000);
  }
```
상품리스트(배열)에 상품을 추가하는 거야 그런데 내가 해당코드를 삭제하면
1초 후에 모든 상품이 사라지고 새로 추가한 상품만 남지
한개만 남지 하나만 추가한 것이 아니라 전체 상품리스트들을 대체해버린 것
이전 영화 리스트를 그대로 두고 한개의 영화를 추가
우리는 전체 리스트를 대체하는 것이 아니라 한개만 추가
```js
 this.setState({
    items: [
        ...this.state.items,// 이 코드를 삭제하면
        //이 코드가 명령하는 것은 이전 상품리스트를 그대로 두고 그리고 한개의 상품을 추가 하라는 뜻
        //이 코드를 삽입해서 이전 영화리스트를 그대로 두고 한개의 영화만 추가
        {
            name: '[입생로랑(YSL)]2017 홀리데이 컴플리트 메이크업 팔레트',
            image: 'http://item.ssgcdn.com/27/52/13/item/1000024135227_i1_202.jpg'
        }
    ]
});
```
state를 활용 응용해서 다양한 효과를 볼 수 있음. 인피니티 스크롤 동일한 효과 20개의 영화가 더 추가 로딩
끝까지 스크롤하면 20개의 영화를 추가하면 됨
계속 추가 컨텐츠를 밑에 로딩
이 같은 방식으로 페이스북, 인스타그램이 로딩되고 있지

```js
movies: [
    items: [
        {
            name: '[입생로랑(YSL)]2017 홀리데이 컴플리트 메이크업 팔레트',
            image: 'http://item.ssgcdn.com/27/52/13/item/1000024135227_i1_202.jpg'
        },
        ...this.state.items
    ]
]
```
만약 ...this.state.movies 새로 추가하는 상품 다음에 입력하면 어떻게 될까?
상품 리스트 그 전에 새로운 상품이 출력


# 08. Loading states
이번에는 Loading states에 대해서 이야기 해보자
데이터 없이 컴포넌트가 로딩하고
데이터를 위해 API를 불러서
API가 데이터를 주면 컴포넌트가 state를 업데이트
API콜을 타임아웃 기능으로 유사하게 구현해보자
이를 위해 상품 리스트를 setTimeout 함수로 이동

자 이제 state는 텅 비워있음
1초 기다린 후 상품리스트가 등장하도록

에러 메세지 확인
TypeError: Cannot read property 'map' of undefined
왜냐하면 state.items가 존재하지 않음
map을 돌리려고 하는데 state.items이 없으므로 에러 발생
여기서 로딩 state가 필요함 간단하게 loading이라고 작성
상품이 state에 없을때마다 로딩을 띄우거나 상품리스트를 보이도록하자

영화리스트를 불러오는 새로운 함수(_renderItems)를 만들고
items 라는 변수에 데이터를 저장
```js
  _renderItems = () => {
    const items = this.state.items.map((item, index) => {
        return <Product name={item.name} image={item.image} key={index} />
    });
    return items;
  }
```
그래서 items 데이터가 없을때 로딩으 띄고 있으면 상품이 보이도록 다음과 같이 작업
this.state.items ? 물어보는거야 데이터가 있는지
데이터가 있으면 _renderItems() 만약 데이터가 없으면 로딩중이라고 출력
여기에 왜 언더스코어를 쓰느냐 이유는 리액트 자체에 기능이 많기때문에 리액트 자체 기능과 나의 기능에 차이를 두기 위해서
```js
render() {
    return (
        <div className="App">
            {this.state.items ? this._renderItems() : 'Loading'}
        </div>
    );
}
```
저장 후 확인 1초후 로딩이 나타나고 상품리스트 출력

# 09. Smart vs Dumb Components
클래스기반 컴포넌트와 함수형 컴포넌트의 차이

스테이트의 개념을 사용할 때 클래스를 이용
단순한 컴포넌트로 여러개의 프로퍼티와 정적 JSX를 반환 (가볍고 무척 빠르고 쉽다)

함수로 이루어졌기에 함수형 컴포넌트라고 불림
한 함수가 JSX형태를 반환. 이는 결국 DOM렌더링 그게 다 매우 단순하다

새로운 컴포넌트를 작성하기 전에 자신에게 물어봐야할 질문
이 컴포넌트가 어떤 스테이트든 유지할 필요가 있느냐?

클래스 컴포넌트 
내부적은 정보를 저장하려할때 사용
보다 복합적이고 똑똑한 컴포넌트로 만들기 위해서
사용자가 input에 타이핑을 할때 이 컴포넌트는 다름 컴포넌트에 몇 가지 정보를 알려야 합니다.
예를 들어 사용자가 입력창에 뭔가를 타이핑하고 있어, 타이핑 하는 내용은 이거야
이를 위해 더나은 기능이 필요 클래스 기반의 컴포넌트라는 것을 생성 ES6를 사용해서 만듬

```js
import React from 'react';
class MoviePoster extends React.Component {}
```

React.Component로부터 모든기능을 제공 받으라는 것
다른말로 이 무비포스터는 React.Component클래스에게 받은 기능을 제공한다는 것
메소드 기반의 클래스를 사용. 여전히 그 자체로 렌더링 할 수 있는 능력이 필요
이를 위해 render() 메소드라는 것을 정의

Syntactic sugar
```js
import React, { Component } from 'react';
//{}괄호의 의미는 리액트 라이브러리를 불러와 Component라 부르는 변수를 프로퍼티 형태로 가져오라는 것
//const Component = React.Component; 이렇게 쓰는것과 같은 방식

class MoviePoster extends Component {}
```

class 컴포넌트는 state를 사용할 수 있음
functional컴포넌트는 props만 존재

모든 컴포넌트가 state 있는것은 아님
어떤 컴포넌트는 state없는 stateless functional 컴포넌트
state없고 props밖에 없을때

class 컴포넌트를 쓰는 대신에 functional컴포넌트로 변경
```js
//Movie.js

/*
class MoviePoster extends Component {
  static propTypes = {
    poster: PropTypes.string.isRequired
  }

  render() {
    return (
        <img src={this.props.poster} alt="" />
    );
  }
}
*/

//이전보다 적은양의 코드만 작성
function MoviePoster({poster}) {
  return (
     <img src={poster} alt="" />
  )
}
//그럼 어떻게 propTypes를 확인할 수있을까
//에러메세지 failed prop types 
MoviePoster.propTypes = {
  poster: PropTypes.string.isRequired
}
```
보시다시피 이전보다 적은 양의 코드만 작성해도 됨
그럼 이번엔 Product컴포넌트를 변경 해보자
```js
function Product({name, image}) {
    return (
        <div>
            <ProductImage image={image} />
            <h1>{name}</h1>
        </div>
    )
}
Product.propTypes = {
    name: PropTypes.string.isRequired,
    image: PropTypes.string.isRequired
}
```
functional컴포넌트에서는 this.props를 삭제해 줘야함 클래스가 아니니까
클래스들은 그 안에 this라는 키워드가 있음, functional컴포넌트에서는 this가 필요없음
그냥 html을 return해야할 뿐 여기처럼

# 10. AJAX Promises on React
이제 ajax를 사용해 봅시다
우리가 사용할 포멧은 JSON, 오브젝트를 스크립트로 작성
ajax를 리액트에 적용하는 방법은 fetch 덕분에 간단함

html request에 관한 방법이 많은데 그 중에 fetch request를 만들어 봅시다

우리의 root 컴포넌트로 가서 이전에 작업한 setTimeout대신에 삭제하고 다시 작업
진짜 상품 데이터를 원하니깐

컴포넌트가 mount되면서 해당 url로 가서 fetch해오는 거임
ajax는 url을 자바스크립트로 asynchronous(비동기화) 방법으로 불러옴(JSON 형태로)
무언가를 불러올때마다 페이지를 새로고침하지 않음

```js
componentDidMount() {
    console.log(fetch('http://event.ssg.com/event/getLeafItemIdsItemList.ssg?itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673'))
}

Promise {[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined}


fetch('https://randomuser.me/api/?results=10') // Call the fetch function passing the url of the API as a parameter
.then(function() {
    // Your code for handling the data you get from the API
})
.catch(function() {
    // This is where you run code if the server returns any errors
});
```


### javascript ajax 통신, jsonp 의 모든 것
https://blog.seotory.com/post/2016/04/understand-jsonp
jsonp 란?
전통적인 웹 브라우져에서는 same-origin policy (SOP) 정책에 따라 다른 도메인간의 request을 제한하고 있다. 
그러나 <script/> 태그는 same-origin-policy (SOP) 정책에 속하지 않는다는 사실을 근거로, 
서로 다른 도메인간의 javascript 호출을 위하여 jsonp (또는 json with padding) 이 사용되었다.

```js
function myCallBack(data) { 
  console.log(data.resultMsg); 
}

var script = document.createElement('script'); script.src = 'https://event.ssg.com/event/getLeafItemIdsItemList.ssg?callBack=myCallBack&itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673';
document.getElementsByTagName('head')[0].appendChild(script);
```
### Fetch JSONP
https://github.com/camsong/fetch-jsonp
```bash
npm install fetch-jsonp --save
```

# Promises
Promises는 새로운 자바스크립트 컨셉
이게 새로운 이유는 asynchronous programming때문에
asynchronous가 무엇이냐?

console.log(fetch('url'));
console.log('hello');

예를 들어 여기 여러라인이 있어 또다른 새로운 라인이지
두번째 라인 헬로우는 첫번째라인 fetch가 끝나지 않으면 실행되지 않아
이걸 synchronous 동기라고 하지 좋을때도 있지만 별로일때도 있음
여러가지 작업을 할 수가 없음, 왜냐하면 첫번째 라인 작업이 끝날때까지 기다려야 하니까

프로미스는 비동기(asynchronous)야, 첫번째 라인이 끝나든 말든 두번째 라인이 작업을 한다는 뜻
이게 좋은 이유는 계속 다른 작업을 계속 스케줄해놓을 수 있기 때문에 그리고 모든 작업들은
다른작업 수행이랑 관계없이 진행됨 다른작업이 끝나기를 기다릴 필요도 없음
또 다른 promises기능은 시나리오를 잡는 방법을 만들어줘 좋은 혹인 나쁜 시나리오
fetch, promises가 좋은 이유는 시나리오가 생기고 이를 관리할 수있기 때문

그럼 프로미스를 적용해보자

 영화 api 작업이 끝나야 애니메이션 api를 불러올 수 있음
 fetch, promises가 좋은 이유는 시나리오가 생기고 이를 관리할 수 있음
 Promises는 너가 성공적으로 수행할 수있고 그렇지 않을 경우 결과물을 catch, then으로 받아 볼 수 있음 

```js
    const url = 'https://event.ssg.com/event/getLeafItemIdsItemList.ssg?itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673';

    fetch(url) //이 라인 완료되면
    .then(response => response.json())  //무언가를 해라
    .then(json => console.log(json))
    .catch(err => console.log(err)) //근데 fetch 라인에 에러가 있으면 catch 잡아서 나에게 보여줘


    fetchJsonp(url, {
      jsonpCallback: 'callBack'
    })
    .then(response => response.json())
    .then(data => {
      console.log(data.resultMsg);
    })
    .catch(error => {
      console.log('Error fetching and parsing data', error);
    });

```
then() response 살펴보기
* body: ReadableStream //이 뜻은 바이트(010101..)로 이루어져있다는 뜻, 이걸 json으로 변경 
.then(response => response.json())
* bodyUsed: false //아직 사용하지 않음

프로미스는 너가 성공적으로 수행할 수 있고 그렇지 않을 경우 결과물을 catch, then으로 받아 볼 수 있음
fetch가 좋은 이유는 url을 ajax로 아주 간단하게 불러올 수 있음
이전에는 xml http request라고 복잡하고 어려웠음 (길고 어려운 코드) 

# 11. Async Await
Async Await는 지난 시간에 작성한 이 라인들을(fetch then catch) 좀 더 분명하게 작성해주는 도구

```js
    const url = 'https://event.ssg.com/event/getLeafItemIdsItemList.ssg?itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673';

fetch(url)
.then(response => response.json())
.then(json => {
    //이런 식으로 작성하면 세련도지 않음
    //그리고 애플리케이션이 커지면 then 안에 then으로 이어지면서 call back hell이라는  것에 빠짐
    //뭐 아는 사람들은 다 알거야 then then then.. 많아져서 길을 잃어버리는 거지
    this.setState({
        items: json.data.items
    })
    .then(() => then())
    CALL HELL!!
})
.catch(err => console.log(err))
```
그래서 여기서 async await라는 것을 쓸거야
새로운 function을 만들거야 _callApi, _getMovies
왜 이렇게 쓰느냐 
큰 컴포넌트 did mount갖고 싶지 않아 
사이즈가 크면 좋은 코딩방법이 아니야 왜냐면 많은 function을 불러올건데
다 한 군데 몰아있는 것보다 작은 function들이 각기 다른 장소에 있는 것이 좋음

```js
  componentDidMount() {
    this._getMovies();
  }

  _callApi = () => {
    const url = 'https://event.ssg.com/event/getLeafItemIdsItemList.ssg?itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673';

    fetchJsonp(url, {
      jsonpCallback: 'callBack'
    })
    .then(response => response.json())
    .then(data => data.resultMsg)
    .catch(error => {
      console.log('Error fetching and parsing data', error);
    });
  }

  _getMovies = () => {

  }
```

async(동기): 이전 라인의 작업이 끝날 때까지 기다리는 것이 아닐때
이전 작업이 끝나야 그 다음 작업이 시작하는 형태가 아니야, 순서와 상관없이 작업이 진행 
function getMovies는 asynchronous function이라고 할 수 있어
이 안에 await이라고 쓸거야 

await: _callApi기능이 끝나는것을 기다리고 '끝나기를' 기다리는 거임('성공적으로 수행'이 아니라)
_callApi의 return value가 그것이 무엇이든
_callApi의 return value를 movies에 set할거야 
그리고 이 컴포넌트의 setState을 movies로 할거야 그건  _callApi의 value
```js
_getMovies = async() => { //asynchronous function
    const items = await this._callApi();
    //이 부분 setState는 _callApi작업이 되기 전까지 실행되지 않음, '작업이 완료'되기 전까지 '성공적 수행'이 아니라
    //성공적 실패로 끝날 수 있어, 하지만 작업이 완료 되어야 해
    this.setState({
        items 
    });
    //그리고 컴포넌트 state를 items로 세팅
    //items: items (es6)
    //state안에 items가 있으면 _renderItems function을 불러옴
}
```
이를 하는 방법은 fetch라는 이름의 promise를 return 할꺼야
```js
  _callApi = () => {
    const url = 'https://event.ssg.com/event/getLeafItemIdsItemList.ssg?itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673';

    return fetchJsonp(url, {
      jsonpCallback: 'callBack'
    })
    .then(response => response.json())
    .then(data => data.resultMsg)
    .catch(error => {
      console.log('Error fetching and parsing data', error);
    });
  }
```

콘솔창 오류 확인 상품명과 이미지가 출력이 제대로 안되고 있음
상품명과 이미지는 필요한 항목이라고 적혀있는데 value가 undefined 되어 있다
왜냐면 items 오브젝트가 변경되었기 때문에
이전에는 우리가 오브젝트를 만들었지만 지금은 전혀 다름, 
콘솔로 item을 다시 살펴보자
```js
     //before _renderItems
    <Product name={item.name} image={item.image} key={index} /> 
    //item 오브젝트에 name과 image는 없음, 
    //근데 item.name, item.image를 찾고 있음

    //after _renderItems
    <Product name={item.itemNm} image={item.imgPath} key={index} />
    //그래서 이름을 itemNm, 이미지를 imgPath로 바꿔주면 됨
```

key는 상품의 id를 사용해도 됨
상품에 itemId가 있음 인덱스 대신에 item.itemId를 사용하자
왜 id를 사용하느냐?
컴포넌트의 키는 index를 사용하는것은 좋지 않음. 느림
```js
  _renderItems = () => {
    const items = this.state.items.map((item, index) => {
      return <Product name={item.itemNm} image={item.imgPath} key={item.itemId} />
    });
    return items;
  }
```


# 12. Updating Items Component
상품유닛에서 보듯이 상품이미지, 상품명, 가격, 브랜드, 링크, 딱지... 등의 데이터가 필요. 데이터 확인 후 추가
```js
//App.js
  _renderItems = () => {
    const items = this.state.items.map((item, index) => {
      console.log(item);
      return <Product
        soldout={item.soldOutYn}  
        name={item.itemNm} 
        image={item.imgPath}
        price={item.price}
        link={item.lnkdUrl}
        key={item.itemId} />
    });
    return items;
  }
```
이제 우리의 Product.js 컴포넌트의 props를 업데이트하면 됨
prop type 다음에 가격, 가격, 브랜드, 링크, 딱지를 추가하자
```js
//Product.js
Product.propTypes = {
    soldout: PropTypes.string.isRequired,
    name: PropTypes.string.isRequired,
    image: PropTypes.string.isRequired,
    price: PropTypes.string.isRequired,
    link: PropTypes.string.isRequired,
}
```

이제 html을 좀 더 예쁘게 써보자

className는 정상적인 css에서 class를 뜻 함
하지만, JSX에서는 className이라고 써야함

만약, 그냥 class라고 쓰면? 리액트가 알려줄거야
그러니 돌아가서 className라고 변경하고

이 className라고 쓰는 것은 여기에 있는 다른 키워드 class나 
클래스 기반 컴포넌트와 이름이 혼동되기 때문에

```js
//Product.js
function Product({ soldout, name, image, price, link }) {
    return (
        <li>
            <div className='cunit_prod'>
                <div className="thmb">
                    <a href={link}>
                        <ProductImage image={image} alt={name} />
                    </a>
                </div>
            </div>
            <div className="cunit_info">
                <div className="cunit_md">
                    <div className="title"><a href={link}>{name}</a></div>
                </div>
                <div className="cunit_price">
                    <div className="opt_price">
                        <span className="blind">판매가</span>
                        <em className="ssg_price">{price}</em> <span className="ssg_tx">원</span>
                    </div>
                </div>
            </div>
        </li>
    )
}
```



ProductImage에 alt값 추가
alt는 타이틀 이라고 하자
```js
function ProductImage({image, alt}) {
    return (
        <img src={image} alt={alt} title={alt} width="232" height="232" />
    )
}
ProductImage.propTypes = {
    image: PropTypes.string.isRequired,
    alt: PropTypes.string.isRequired
}
```
품절 대응
```js
function Product({ soldout, name, image, price, link }) {
    return (
        <li>
            <div className={soldout === 'Y' ? 'cunit_prod cunit_soldout' : 'cunit_prod'}>
                <div className="thmb">
                    <a href={link}>
                        <ProductImage image={soldout === 'Y' ? 'http://img.ssgcdn.com/trans.ssg?src=/ui/ssg/img/common/img_ready_500x500.jpg&w=232&h=232' : image} alt={name} />
                    </a>
                </div>
            </div>
        </li>
    )
} 
```




정리
내가 한것은 props를 더 추가 한거야
장르와, 시놉시스와 같은 이전에는 포스터와 타이틀 밖에 없었지
props를 더 추가하고 Movie컴포넌트에 등록했지
그다음 기본html을 작업했어 클래스명 추가 JSX, 컬럼 Movie포스터를 만들고 제목 만들고, 장르 array를 맵핑하고 무비 시놉시스 클래스를 만들었지
그리고 alt이미지를 만들었어
그리고 장르를 맵핑할때 MovieGenre라는 새로운 컴포넌트를 만들었어 functional컴포넌트로 간단한 span을 return하게 끔
그냥 span을 쓸 수도 있지만 별도로 컴포넌트를 생성한 이유는 이게 더 세련된 코딩방식이기 때문에
모든걸 컴포넌트로 쪼개고 작게 만드는것이 더 세련됨
이제 이 정보들을 이쁜 css에 담으면 됨

# 13. CSS for Movie

# 14. Building for Production 깃허브 페이지 배포 (deploy)

깃허브 페이지 gh-pages는 코드를 실행하고 웹사이트를 봄
static file을 올림
```bash
$ npm run build
```
이건 css를 가져다가 압축 그리고 이를 build라는 public폴더에 넣을 꺼야 
우리가 로컬호스트에 있을때 사용하는 코드는 압축되어있지 않고 느리고 최적화 되어 있지 않았지
build작업을 하면 좀 더 최적화 되고 압축 더 향상 되는것이지

그리고 터미널의 메세지 확인
The project was built assuming it is hosted at the server root.
To override this, specify the homepage in your package.json.
For example, add this to build it for GitHub Pages:
"homepage" : "http://myname.github.io/myapp",

바로 이작업을 우리가 할 꺼야
package.json으로 가서 홈페이지 key를 추가 저장하고 다시 빌드
"homepage": "http://hohoya33.github.io/react-ssg"


# gh-pages Branch
github 접속 Create a new repository 
Repository name 입력
Initialize this repository with a README 체크

Branch:master 버튼 클릭
gh-pages 추가

Setting > Branches > Default branch gh-pages선택 후 Update > I understand update...클릭
첫페이지 이동 후  > 상단 branch클릭 > master 브랜치 삭제

* git 생성
$ git init
$ git remote add origin https://github.com/hohoya33/react-ssg.git


다시 메세지 확인
```bash
$ npm install --save-dev gh-pages
```

gh-pages 설치 후 아래 스크립트를 package.json에 추가
 // ...
"scripts": {
    // ...
    "predeploy": "npm run build",
    "deploy": "gh-pages -d build"



```bash
$ npm run deploy
```
 유저명, 비번 입력
 깃허브 페이지 확인



---

만약 이와 같은 구문에러를 만나면 npm start를 통해 무엇이 잘못되었는지 정확히 짚어줄것입니다.

this.setState({ videos: videos });
ES6로 이부분을 보다 압축 시킬 수 있습니다. key, value가 있을 때

this.setState({ videos }); 
이와 같은 형태로 변형되어 인식
이는 약간의 신텍스 슈가로 우리의 코드를 정리하기 위한 것. 오직 키와 변수 이름이 같을때 동작
이와 같은 고급 구문이 리액트에서 자주 사용, 일반적으로 이것이 혼란스럽게 보여도 이를 익숙해지려고 노력해보면서 
코드를 장기적으로 정리하는 연습을 길들이길 권합니다.


여기 재미있는 부분이 있는데요.
app은 비디오 리스트의 부모이고 비디오 리스트는 app 스테이트의 videos를 접근이 가능합니다.
비디오 리스트의 참조가 필요
기본적으로 부모 컴포넌트인 app에서 자식 컴포넌트인 비디오 리스트로 데이터를 전달해야 하는데 
부모컴포넌트로 부터 데이터를 자식 컴포넌트인 비디오 리스트로 전달하는것은 매우 간단 명료합니다.
비디오 리스트의 JSX 태그 위에 프로퍼티를 정의하면 되는데 이와같이 videos는 자바스크립트 변수를 참조하게 해야하는데
<VideoList videos={this.state.videos} />
괄호를 사용해서 this.state.videos를 작성. 이 데이터를 전달하는 것은 리액트의 props을 참조하게 되는데 

함수형 컴포넌트를 사용하면 이 props의 오브젝트는 함수의 요소로 들어갑니다.
const VideoList = (props) => {
    const videos = props.videos;
}
예를 들어 여기에 props.videos 처럼 정의해서 데이터를 가져올 수 있음

클래스 기반의 컴포넌트의 props는 어느 메소드에서 this.props를 정의해서 사용할 수 있움
즉 렌더링 메소드 안에 this.props가 그 자체나 부모 컴포넌트에 의해 어떤 프로퍼티 형태로 전달 받을 수 있는 것이죠
함수형 기반 컴포넌트를 클래스 기반 컴포넌트로 리팩토링할 때 알아야 할 중요한 것은 이 props를 this.props로 바꿔야 한다는 것입니다.


const VideoList = ({videos}) => { 
    //여기 {videos}는 아래 코드와 동일 줄여서 표현
    //const videos = props.videos;
    요소의 첫번째 객체가 비디오 프로퍼티로 나타나게 되고 비디오를 가져와 새로운 비디오나 새로운 변수를 생성하라는 의미
}


const url = 'https://www.youtube.com/embed/' + videoId;
우리는 이 문자열을 연결 혹은 템플릿 문자열이라 부를건데
ES6에서 하나의 문자열을 연결하거나 접선시킬때 보다 나은 구문으로 변경 시킬 수 있는데요
두개의 따옴표를 지우고 이를 백틱 문자열로 둘러쌉니다. 키보드 상단의 맨 왼쪽
여기안에 $달러 구문을 넣고 중괄호안에 비디오 아이디를 넣습니다. 
const url = `https://www.youtube.com/embed/${videoId}`;
단순히 두개의 문자열을 연결하는 것보다 읽기 좋다고 할 수있습니다.


비디오 리스트를 가져오기 위해 리퀘스트를 요청, video프로퍼티는 undefined를 VideoDetail에게 보냄
그래서 VideoDetail컴포넌트가 렌더링을 시도하기 전에 비디오가 props에 주어졌는지 확인하는 과정
우리는 비디오 프로퍼티가 있는지 컴포넌트를 렌더링하기 전에 
상단에 체크사항 추가
로딩을 반환 하도록 합니다.

if(!videos) {
    return <div>Loding...</div>
}


# 탑레벨 컴포넌트에서 자식컴포넌트에 콜백함수 이벤트 전달 
이와같은 콜백은 부모컴포넌트부터 자식컴포넌트들로 전달
부모컴포넌트와 자식컴포넌트가 소통하기 위한 훌륭한 방법
이렇게 두 레벨 이상으로 넘어가는것은 약간 드문 일(일반적으로 두 단계 넘어가는것은 복잡함)
```js
//index.js 탑레벨 컴포넌트
class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            videos: [],
            selectedVideo: null
        };

        YTSearch({key: API_KEY, term: 'surfboards'}, (videos) => {
            this.setState({
                videos: videos,
                selectedVideo: videos[0]
            });
        });

    }
    render(){
        return (
            <div>
                <SearcheBar />
                <VideoDetail video={ this.state.selectedVideo } />
                <VideoList 
                    onVideoSelect={ selectVideo => this.setState({selectedVideo}) } 
                    //이 함수는 하나의 목적을 가지고 있죠, 스테이트를 업데이트 
                    //비디오를 가져와서 선택한 비디오를 업데이트 합니다.
                    //이 프로퍼티를 비디오 리스트로 전달
                    videos={ this.state.videos }
                />
            </div>
        );
    }
}

//video_list.js
const VideoList = (props) => {
    const videoItems = props.videos.map((video) => {
        return (
            <VideoListItem
                onVideoSelect={props.onVideoSelect}
                //비디오 리스트는 프로퍼티를 가져와 비디오 리스트 아이템에 전달합니다.
                key={video.etag}
                video={video}
            />
        );
    });

    return (
        <ul>{videoItems}</ul>
    );
}

//video_list_item.js
const VideoListItem = ({video, onVideoSelect}) = > {
    return(
        <li onClick={() => onVideoSelect(video)}></li>
        //이 프로퍼티는 클릭할때마다 전달한 함수를 호출 합니다.
        //각 비디오 리스트 아이템은 다른 비디오를 가지고 있기 때문에 해당 비디오를 보게 됩니다.
    );
}

```







# 비디오 검색
```js
//index.js 탑레벨 컴포넌트
class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            videos: [],
            selectedVideo: null
        };

        this.videoSearch('surfboards');
    }
    //이 메소드안에 검색 메커니즘을 넣었는데요
    videoSearch(term){
        YTSearch({key: API_KEY, term: term}, (videos) => {
            this.setState({
                videos: videos,
                selectedVideo: videos[0]
            });
        });
    }
    render(){
        return(
            <div>
                <SearcheBar onSearchTermChange={ term => this.videoSearch(term) } />
                //이 의미는 이를 검색바 컴포넌트에 넘길 수 있다는 거죠
                //이 검색바가 검색어가 바뀌면 이를 term과 함께 videosSearch에 전달하여 호출

                <VideoDetail video={ this.state.selectedVideo } />
                <VideoList 
                    onVideoSelect={ selectVideo => this.setState({selectedVideo}) } 
                    videos={ this.state.videos }
                />
            </div>
        );
    }
}

//search_bar.js
class SearchBar extends Component {
    constructor(props){
        super(props);
        this.state = { term: '' };
    }
    onInputChange(term){
        this.setState({term});
        this.props.onSearchTermChange(term);
        //검색어가 새 검색어로 바뀔때 이를 호출
    }
    render(){
        return(
            <div className="search-bar">
                <input 
                    value={ this.state.term }
                    onChange={ event => this.onInputChange(event.target.value) }
                />
            </div>
        );
    }
}
```

# 인풋 검색어 조절 lodash
lodash라 불리는 함수 라이브러리를 이용. 많은 유틸리티 메소드가 있는데 그 중 하나는 debounce입니다.
이는 함수호출 시기를 조절 할 수 있지요.
첫번째로 해야할 일은 lodash를 설치
npm을 사용해서 따로 라이브러리를 설치 할게요. 터미널에서 이런식으로 작성합니다.
```bash
$ npm install --save lodash
```

이제 상단에 lodash를 가져올 것인데요 lodash라고 적기보다 _라고 정의할게요
이제 이를 어떻게 처리할지 이야기 해보겠습니다. 
```js
//index.js 탑레벨 컴포넌트
import _ from 'lodash';

class App extends Component {
    ...
    render(){
        const videoSearch = _.debounce((term) => { this.videoSearch(term) }, 300);
        //이는 효과적으로 새 검색을 매 300밀리초 마다 호출 사켜라는 의미
        //너무 자주 검색이 되지 않게하는 것이죠
        return(
            <div>
                <SearcheBar onSearchTermChange={ videoSearch } />
                <VideoDetail video={ this.state.selectedVideo } />
                <VideoList 
                    onVideoSelect={ selectVideo => this.setState({selectedVideo}) } 
                    videos={ this.state.videos }
                />
            </div>
        );
    }
}
```

# 리액트 마무리
어떻게 리액트가 동작하는지 이해했으면 여기 주의를 기울여야할 여러가지 컨셉을 요약해 보겠습니다.
첫번째로 클래스기반 컴포넌트와 함수형 컴포넌트의 차이
다음에 이야기 할것은 스테이트인데요, 이는 무척 까다로운 개념입니다.
클래스를 생성하는 것은 스테이트를 초기화 하는데 깔끔한 작업방법. 왜냐하면 스테이트를 초기화 할때 연관된 메소드가 있는데요
클래스 기반 컴포넌트에서는 constructor안에서 스테이트를 세팅합니다. 
this.state구문을 쓴것과 반대로 다른곳에서 this.setState를 작성하면 약간 혼란스럽죠
또하나 스테이트에대해 알아야 할것은 이 스테이트가 바뀔때마다 즉시 렌더링 되고 이 컴포넌트를 가지는 자식에게도 영향을 미칩니다.

마지막으로 기억해야할 것은 불러오기 구문과 내보내기 구문
인덱스 파일에는 여러 임폴트 구문이 있는데 컴포넌트 디렉토리로 부터 파일을 불러오죠
이 파일을 불러올때마다 상대경로로 작성, 반면에 라이브러리를 사용하려면 라이브러리의 이름을 넣습니다.


```js
//SearchForm.js
import React, { Component } from 'react';

export default class SearchForm extends Component {
    state = {
        searchText: ''
    }

    onSearchChange = e => {
        this.setState({ searchText: e.target.value });
    }

    handleSubmit = e => {
        e.preventDefault();
        this.props.onSearch(this.state.searchText);
        e.currentTarget.reset();
    }

    render() {
        return (
            <from className="search-form" onSubmit={this.handleSubmit}>
                <label className="is-hidden" htmlFor="search">
                <input type="search"
                    onChange={this.onSearchChange}
                    name="search"
                    placeholder="Search..."
                />
                <button type="submit" id="submit" className="search-button"><i className="materia">Search</button>
            </form>
        );
    }
}


```





%PUBLIC_URL%
const envPublicUrl = process.env.PUBLIC_URL;


```bash

```

```js
//------ App.js ------

```

### XHR (AJAX) Requests
```bash
npm i axios --save-dev
```




 //const url = 'https://event.ssg.com/event/getLeafItemIdsItemList.ssg';
    //const url = 'https://yts.ag/api/v2/list_movies.json?sort_by=rating';
    //const url = 'http://api.giphy.com/v1/gifs/trending?api_key=dc6zaTOxFJmzC';

  

/*
    fetch('https://event.ssg.com/event/getLeafItemIdsItemList.ssg?callBack=myCallBack&itemIds=1000021158816,1000023150825,1000017480115,1000024135227,2097000201672,1000022797673', {
        //mode: "no-cors",
        method: "GET",
        headers: {
          "Accept": "application/json"
        }
      })
      .then((response) => {


        response.text().then(function (text) {
          function myCallBack(data) {
            console.log(data.resultMsg)
          }
          var fn = new Function(text);
          fn();
          //console.log(text.replace('myCallBack(', ''));

          //str.replace(/#/gi, ""); 
          //console.log(text.substring(11, text.length));
          //console.log(JSON.stringify(text));

          //var json = JSON.parse(JSON.stringify(text));
          //console.log(typeof json);
        });
        
        //console.log(response.json());
        //console.log(JSON.stringify(response.text()));

        console.log(response.type);
      })
      .then((responseText) => {
        // function myCallBack(data) {
        //   console.log(data.resultMsg)
        // }
        // console.log(eval(responseText));
        
      })
      .catch(err => console.log(err))

*/


    /*

    const url = 'https://randomuser.me/api/?results=10';
    fetch(url)
      //.then((resp) => resp.json())
      .then(function (data) {
        console.log(data);
        let authors = data.results;
        // return authors.map(function (author) {
        //   let li = createNode('li'),
        //     img = createNode('img'),
        //     span = createNode('span');
        //   img.src = author.picture.medium;
        //   span.innerHTML = `${author.name.first} ${author.name.last}`;
        //   append(li, img);
        //   append(li, span);
        //   append(ul, li);
        // })
      })
      .catch(function (error) {
        console.log(error);
      });   
      */
