### React?
사용자 인터페이스를 만드는 자바스크립트 라이브러리
컴포넌트를 통한 View표현만 담당


Facebook이 만들고 있는 이른바 MVC 프레임워크에서의 뷰(View) 부분을 컴포넌트로 만들기위한 라이브러리입니다.
React는 Facebook에서 개발해 Facebook과 Instagram, Airbnb 등에서 사용하고 있는

사용자 액션에 따라 DOM을 일일이 다루었던 과거 개발 방식(jQuery와 같은 라이브러리만을 사용하는)과는 달리 
개발자가 DOM을 직접 다루지 않고 React가 데이터 상태에 따라 자동으로 UI를 관리하기 때문에, 개발자는 단순히 특정 상태에 대한 뷰의 변화만 구현하면 된다.

React 특징

UI 컴포넌트를 만들기 위한 라이브러리이며 React의 컴포넌트는 트리형태로 구성된다.
Virtual DOM을 사용하여 변경된 부분에 대한 최소한의 DOM 처리로 UI를 업데이트하여 애플리케이션의 성능을 향상한다.
부모 컴포넌트에서 하위 컴포넌트로 전달하는 단방향의 단순한 데이터 흐름을 갖고 있어 데이터 추적과 디버깅을 쉽게 해준다.

### React 특징
* 리액트가 왜 전세계적으로 열광하고 인기있는지??
* 자바스크립트 기반, 별도로 다른 프레임워크를 배울필요없음 그냥 자바스크립트를 활용
* 리액트를 하면서 동시에 자바스크립트 기술 향상
* 리액트 구조는 요소별, 컴포넌트별로 나눠서 작업을 할 수있게 되어 있음
Composition 자세히 뜯어보면
<Nav />
<Header />
<Number />
<Grid />
요소들로 볼 수 있음
그룹별료 쪼개서 작업을 할 수 있음
모든걸 작은 요소 (components)로 쪼개서 작업, 마무리하면 가져다가 다른 곳에 쓸 수있음 

* JSX
리액트로 html을 쓰는 방법

* 단방향 데이터플로우 Unidirectional
데이터는 항상 일정한 장소에 위치해있고, 그 장소에서만 변경 할 수 있음
리액트의 경우 데이터는 위치한 장소에 있고 
상태가 변했을 경우 데이터는 그대로 있고, UI가 업데이트 됨


데이터가 변하면 UI가 업데이트됨
데이티가 안변하면, UI도 안변하겠지
데이터가 변하면 UI는 새로운 데이터와 함께 업데이트 됨
즉 UI에서는 데이터를 바꿀 수는 없어
항상 같은 방향 데이터 -> 데이터 변경 -> UI변경



### 설치
https://github.com/facebookincubator/create-react-app 

```bash
npm install -g create-react-app
```

### Creating an App
```bash
create-react-app my-app
cd my-app/

npm start
```

# 2. Creating React Components with JSX
* React와 ReactDOM의 차이
React는 UI라이브러리
ReactDOM은 리액트를 웹사이트에 출력(render)하는걸 도와주는 모델
리액트를 웹사이트에 올려놓고 싶다 그럴때는 리액트돔을 사용
리액트를 모바일앱에 올려놓고 싶다 그럴때는 리액트네이티브를 쓴다

리액트돔은 1개의 컴포넌트를 출력(render)하고
도큐먼트안에 엘리먼트가 있는데 엘리먼트 ID는 root, index.html 파일안에 있음
렌더를 하면 모든 컴포넌트들이 여기로 출력됨

우리가 만들기 시작할 컴포넌트는 App, 여기에 모든 영화내용, 정보를 넣음 지금은 텅텅비워있음

새로운 컴포넌트를 만들자 new file Movie.js, Movie.css
App.js처럼 사용 동일하기 작성
class Movie..작성
컴포넌트는 항상 render를 해야함
export를 작성해서 app.js로 해당 컴포넌트를 내보냄

이렇게 작성된 movie컴포넌트를 App컴포넌트 안에다가 레고조각모음 하는거 마냥 
집어넣으면 됨

컴포넌트 생성 -> 렌더 -> 리턴 -> html내용 -> 브라우저에서 확인

Movie컴포넌트를 app.js에서 여러번 불러올 수도 있음
Movie컴포넌트 안에 실제 영화 정보를 작성 포스터를 넣어보자
클래스 명은 MoviePoster. renter > return > 이미지소스

보시다시피 큰 컴포넌트 안에 작은 컴포넌트를 집어넣는 방식으로 작업을 함
그리고 Movie 컴포넌트안에 제목, 정보 등 또다른 작은 컴포넌트들이 있음
컴포넌트를 만들었으니 이제 컴포넌트를 아름답게 만들고 데이터랑 연동하고 리스트에 출력


또하나 염두해야할 것
여기에 React와 같은 변수를 참조하지 않았음에도 여전히 이것을 불러오는것이 필요합니다. import React from 'react'

모듈을 export할때 이렇게 상단에 선언하는 이유는
JSX를 평범한 자바스크립트로 변환할때마다 이는 React.createElement와 같은 형태로 변환되기 때문
그리고 리액트가 이범위안에 없으면 이를 지나쳐버릴 것입니다.
그래서 리액트를 JSX를 가지는 모든 컴포넌트에 임폴트하는 것을 확인


# 3. Data flow with Props
리액트에는 2개의 주요컨셉, 하나는 state 나머지 하나는 props

App.js에서 모든 영화를 가져옴(메인 컴포넌트에 무비리스트가 있음)
그리고 그 리스트안에 해당 영화의 정보가 담김
즉, 부모컴포넌트는 자식 컴포넌트에 각각 정보를 전달함
제목을 적고 각각의 영화에 다른 제목을 부여함

```js
//app.js
const movieTitle = [
    'Thor: Ragnarok',
    'THE OUTLAWS',
    'Geostorm',
];
const movieImages = [
    'http://movie.phinf.naver.net/20170928_85/1506564710105ua5fS_PNG/movie_image.jpg?type=m203_290_2',
    'http://movie.phinf.naver.net/20170915_299/1505458505658vbKcN_JPEG/movie_image.jpg?type=m203_290_2',
    'http://movie2.phinf.naver.net/20170922_133/1506059018478U7ur6_JPEG/movie_image.jpg?type=m203_290_2'
];

class App extends Component {
  render() {
    return (
        <div className="App">
            <Movie title={movieTitle[0]} poster={movieImages[0]} />
            <Movie title={movieTitle[1]} poster={movieImages[1]} />
            <Movie title={movieTitle[2]} poster={movieImages[2]} />
        </div>
    );
  }
}

//movie.js
class Movie extends Component {
  render() {
    return (
        <div className="MovieList">
            <MoviePoster poster={this.props.poster} />
            <h1>{this.props.title}</h1>
        </div>
    );
  }
}
```
그리고 Movie컴포넌트에서 각 영화의 제목은 props를 통해 받음. 각 요소들을 액세스하는 방법{this.props.title}
이렇게 부모 컴포넌트가 자식컴포넌트에 정보를 주는 것
JSX의 경우 명령을 실행시키려면 괄호{}를 꼭 사용해야함

부모컴포넌트는 이제 타이틀, 포스터를 자식 컴포넌트(movie)에게 줄거야
movie컴포넌트에서 포스터 이미지만 MoviePoster에게 줄꺼야 
```js
class MoviePoster extends Component {
  render() {
    return (
        <img src={this.props.poster} alt="" />
    );
  }
}
```

데이터 소스는 한군데 메인컴포넌트가 데이터를 다 가지고 있음
타이틀, 영화포스터 정보를 메인에다가 다 집어넣고 그걸 각각 컴포넌트에 props를 이용해 정보를 출력
이를 이용해 강력한 UI를 구축 할 수 있음


# 4. Lists with .map
영화정보를 토대로 리스트 제작
이전에 만든 리스트는 효율적이지 않음, 계속 복사붙여넣기 할 수 없음 
API에서 끍어온 엄청난 양의 영화정보를 불러오고 싶을 때
이를 위해 배열 생성
이 리스트에는 여러 오브젝트가 있음 



다음에 해야할 것은 반복자인 루프를 만드는 것입니다.
이는 자바스크립트의 for루프를 의미하는것이 아닌데요
일반적으로 가능하면 for 루프로 부터 떨어져 있기를 충고해드림
대신에 map과 같은 이터레이터를 사용하길 권합니다.
이 map를 사용하지 않더라도 문제는 없지요. 자바스크립트 구문을 쓴다면 배열을 반복하기 위해 배열을 선언하고
for문을 이용해 배열을 루핑하지요. 이와같은 방식은 때때로 헷갈리고 타이핑 시에 실수도 발생하는데요
대신에 빌드인 헬퍼인 map를 사용할 것입니다.
map는 배열의 프로퍼티구요, map은 함수를 반환합니다. 이 map을 통해 새로운 배열이 반환, 각 값들은 이 함수를 통해서 새로 반환
그래서 이 map을 사용하는 것은 리액트에서 리스트를 만들기 위한 매우 편리한 방법



JavaScript - Map
"map() 메소드는 파라미터로 전달 된 함수를 통하여 배열 내의 각 요소를 처리해서 그 결과로 새로운 배열을 생성합니다."
```js
//app.js
const movies = [
    {
        title: 'Thor: Ragnarok',
        poster: 'http://movie.phinf.naver.net/20170928_85/1506564710105ua5fS_PNG/movie_image.jpg?type=m203_290_2'
    },
    {
        title: 'THE OUTLAWS',
        poster: 'http://movie.phinf.naver.net/20170915_299/1505458505658vbKcN_JPEG/movie_image.jpg?type=m203_290_2'
    },
        {
        title: 'Geostorm',
        poster: 'http://movie2.phinf.naver.net/20170922_133/1506059018478U7ur6_JPEG/movie_image.jpg?type=m203_290_2'
    }
];
```
array들은 map이라는 기능을 사용할 수 있음
map은 새로운 배열을 만듬
```js
//app.js
class App extends Component {
  render() {
    return (
        <div className="App">
            {movies.map(movie => {
                return <Movie title={movie.title} poster={movie.poster} />
            })}
        </div>
    );
  }
}
```
이렇게 리스트를 만듬. 배열 하나를 잡고 매핑(map)해서 하나의 컴포넌트를 만듬

console에서 확인한 에러
Each child in an array or iterator should have a unique "key" prop.
리액트의 경우 엘리먼트가 많을 경우 key값을 줘야함. 이 key는 고유해야함
각 리스트 아이템에 키를 넣어서 리액트가 빠른 방법으로 적적한 레코드를 업데이트 할 수 있음


특별한 키 props를 가져야 한다는 것인데
리액트는 리스트를 렌더링 하는것이 매우 유능한데 어찌보면 약간 과하게 유능합니다.
배열 아이템을 렌더링 할 때 마다 리액트는 리스트를 만드는 것이라 가정합니다.
명백하게 이는 배열이고 리액트는 리스트를 렌더링하는 프로세스를 최대한 최적화 하여 만들것입니다.
당신이 큰 무더기의 노트카드를 가지고 있다고 생각해 보세요 그리고 그것들은 각각 매우 중요한 정보가 업데이트 되거나 프린트 된다고 합시다 

만약 각 카드에 아이디가 있다면 사람들이 여러분에게 하나를 콕집어서 말하기를 아이디 5카드를 업데이트해줘 라고 말하면 프로세스가 훨씬 빨라지죠 

리스트를 만들면서 특별한 요소를 위한 ID를 가지고 있으면 요소가 바뀔때 어떤 요소인지 알아채고 업데이트가 필요한 것이죠
그렇지 않으면 모든것을 버리고 다시 재생성해야 하죠 이 리스트를 위한 키는 무척 명료합니다.


```js
<div className="App">
    {movies.map((movie, index) => {
        return <Movie title={movie.title} poster={movie.poster} key={index} />
    })}
</div>
```

# 5. Validating Props with Prop Types
포스터에 출력되는 값이 숫자나, true/false 같은 값들이 들어오길 원치 않을 때
이걸 확인하는 방법은?
그리고 여기에 2가지 타입을 원한다고 정의, 하나는 타이틀, 나머지는 포스터
타이틀의 경우 리액트 프로퍼티타입은 string
포스터의 경우 위와 동일하게 작성
```js
static propTypes = {
    title: React.PropTypes.string,
    poster: React.PropTypes.string
}
```
React에서 PropTypes deprecated 해결하기
Line 6:  React.PropTypes is deprecated since React 15.5.0, use the npm module prop-types instead  react/no-deprecated

살펴보니, React (15.5.0)에서부터는 React의 main package에 PropTypes가 제거되고, 별도의 라이브러리를 사용하는 식으로 변경되었다.

해결방법

React의 prop-types library 을 설치하기
npm 주소: https://www.npmjs.com/package/prop-types
기존에 React.PropTypes.<typeName> 으로 작성하던 부분을 PropTypes.<typeName> 형태로 작성하면 된다.

```bsh
$ npm install --save prop-types
```
```js
// npm으로 설치 후, 아래와 같이 'prop-types'을 새로 import 
import PropTypes from 'prop-types';

class TestComponent extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            <div>
                <div className='test-title'>
                    {this.props.label}
                </div>
                <div className='test-contents'>
                    {this.props.contents}
                </div>
            </div>
        );
    }
}
TestComponent.propTypes = {
    label: PropTypes.string,
    contents: PropTypes.element
};
```


```js

import PropTypes from 'prop-types';

static propTypes = {
    title: PropTypes.string,
    poster: PropTypes.string
}
```
만약 타이틀이 숫자여야 한다고 지정하면 어떻게 될까?
title: PropTypes.number
에러 출력
우리가 얻게되는 정보가 숫자가 아니라는 것을 체크 할 수 있음
만약 부모 컴포넌트에서 string을 보내면 PropTypes으로 string이라는것을 체크할 수 있다
덕분에 부모 컴포넌트에서 받는 데이터 타입이 무엇인지 체크 할 수 있다


'isRequired'라고 작성하면 movie 컴포넌트는 title이라는 prop을 제공하는 것이 필수로 설정
title: PropTypes.number.isRequired
이 상태에서 타이틀을 삭제하면 어떻게 될까
에러 출력 require필수 조건인 prop이 없다고 알림
필수요건이라고 지정해서 만약 데이터가 없을 경우 에러 메세지를 받을 수 있음
API를 통해 정보를 불러올 때 

# 6. Component Lifecycle
* 리액트 라이프사이클?
컴포넌트는 여러기능을 정해진 순서대로 실행

* Render: componentWillMount() -> render() -> componentDidMount()
이 사이클은 자동으로 발생
콘솔로그 테스트해보자!

컴포넌트가 존재하기 시작하면 리액트는 will mount -> render -> did mount 실행
예를 들면 영화앱같은 어플리케이션을 만들 때 will mount를 진행할때 api작업을 요청
해당 작업 수행이 완료되면 그 다음 데이터 관련 작업 진행

업데이트의 경우?
* Update: componentWillReceiveProps() -> shouldComponetUpdate() -> componentWillUpdate() -> render() -> componentDidUpdate()

componentWillReceiveProps()
컴포넌트가 새로운 props을 받았다는 뜻

shouldComponetUpdate()
리액트는 이전 props이,  새로운 props들과 다르면 업데이트가 발생
그다음 컴포넌트가 업데이트 할거라는 단계로 넘어감

componentWillUpdate()

render()

마지막으로
componentDidUpdate()

렌더를 하거나 업데이트를 할 때 항상 이와 같은 순서로 작동
이를 이해하면 나중에 컴포넌트를 빌드할 때 도움이 됨
예를 들면 componentWillUpdate를 수행 할 때 어플리케이션에 빙글빙글 돌아가는 스피너를 붙일 수 있겠지
업데이트 이 후 componentDidUpdate 에서 돌고있던 로딩중 메세지나 아이콘을 숨김 처리하면 될거야 
컴포넌트 업데이트가 완료 되었으니깐

라이프 사이클의 세부 내용은 실전에서 바로 해보면서 배우도록 하자

# 7. Thinking in React Component State
이번에는 state를 알아보자

스테이트가 바뀔때마다 즉시 리렌더링이 되고 이 컴포넌트를 가지는 자식에게도 영향을 미칩니다.

state는 리액트 컴포넌트 안에 있는 오브젝트
유저 이벤트를 저장하고 반응하는데 이용
우리가 정의한 컴포넌트 기반의 각 클래스는 그 자체의 스테이트 객체를 가집니다.
컴포넌트 스테이트가 바뀔때마다 컴포넌트는 즉시 렌더링하고 자식요소들에게도 렌더링하도록 강제
이 스테이트를 사용하기 전에 스테이트 객체를 초기화


스테이트 프로퍼트를 클래스의 constructor메소드 안에 넣음 
스테이트를 정의하거나 재초기화하는 방법
이때 함수형 컴포넌트는 스테이트를 가지지 않음. 오직 클래스기반 컴포넌트만 가능

모든 자바스크립트의 클래스는 특별한 함수인 constructor가 있음
이 함수는 첫번째로 시작되고 클래스가 생성될때마다 자동으로 실행 새 인스턴스가 생성될때마다 불러지기 때문

constructor함수는 이 클래스 안에서 뭔가를 설정하는데 활용
변수나 상태값을 초기화하는 등에 주로 이용

여기서 super(props)라는 함수 
이 검색바 컴포넌트가 리액트 Component를 상속받는데요
이 Component에는 constructor함수를 가집니다.
부모 클래스에 메소드를 미리 정의 했을때 super를 호출하면서 이 부모 클래스의 메소드를 호출 할 수있습니다.
만약 잘 모르시더라도 걱정하진 마세요 일단 일종에 마법같은거라고 생각하면 됩니다.

오직 constructor함수 안에서만 this.state = { term: '' } 이런코드로 스테이트를 변화 할 수있습니다.
이 값은 다른 컴포넌트 안에서는 항상 this.setState({ term: event.target.value })를 사용

this.state.term = event.target.value 같은 식으로는 절대 변경되지 않습니다. 이런 구문은 절대 쓰지 마세요!!

이 this.setState로만 값 조정이 가능한데요 setState는 지속적으로 유지가 되게 하며
리액트 백단에서 이 스테이트를 위한 많은 여러가지를 하고 있습니다. 만약 이 값을 바꾼다면 리액트는 이 값이 바뀐지 잘 모를텐데요
이를 이 메소드(this.setState)로 리액트에 알리게 되죠
저기요 스테이트가 변했고 여기 새로운 스테이트가 있습니다. 라는 식으로요

JSX안에서 자바스크립트 변수를 참조할때는 {} 중괄호로 이를 감싸줍니다.
여기에 {this.state.term} 작성
이렇게 this.state.term과 같이 작성했지만 이는 term값을 수정하는 것이 아니라 참조하기 위한 조치입니다. 여기에 이런값이 있다고 이야기 해주는 것이죠
이 스테이트값에 4나 5같은 값을 직접 대입 하시면 안됩니다. {this.state.term = '4'} //BAD!!


우리가 인풋요소를 업데이트하거나 값을 변화시킬때마다 change이벤트가 발생, 우리는 스테이트를 세팅하고 this.state.term은 인풋의 새 값을 가지게 됨

스테이트가 업데이트 되거나 this.setState가 호출될때 이는 컴포넌트에 자동적으로 렌더링 신호를 보내고
이 렌더링 메소드의 모든 업데이트된 정보를 DOM에 푸쉬합니다. 왜냐하면 render메소드는 this.state.term을 참조하기 시작하고
컴포넌트가 리렌더링 될때마다 DOM안의 this.state.term이 업데이트 되는 것입니다.
이것이 스테이트의 작동방식이구요


규칙은 다음과 같다
컴포넌트 안에 state가 바뀔때 마다 render()가 발생


```js
class App extends Component {
    //Render: componentWillMount() -> render() -> componentDidMount()
    //Update: componentWillReceiveProps() -> shouldComponetUpdate() -> componentWillUpdate() -> render() -> componentDidUpdate()
    state = {
        greeting: 'Hello'
    }
    componentDidMount() {
        setTimeout(() => {
            this.state.greeting = 'someting';
        }, 5000)
    }
    render() {
        return (
            <div className="App">
                {this.state.greeting}
            </div>
        );
    }
}
```

컴포넌트가 mount되면 5초 기다리고 greeting을 업데이트
지금 작성하는것처럼 써서 greeting를 업데이트 하지 않아
state를 직접적으로 쓰면 안됨
```js
setTimeout(() => {
    this.state.greeting = 'someting';
}, 5000)
```
콘솔창 확인 직접적으로 state를 변경하지 말라라고 경고 표시
//Render: componentWillMount() -> render() -> componentDidMount()
직접적으로 변경하면 위의 render 함수들이 작동을 안함
state를 업데이트 하려면 this.setState를 사용해야 함
여기서 새로운 state를 만들어야 해
```js
this.setState({
    greeting: 'Hello again!'
});
```
이 뜻은 컴포넌트가 마운트 할 때 마다 greeting을 hello -> hello again으로 변경 한다는 뜻
render()가 다시 동작해서 변경 됨
저장 새로고침 확인 hello, 그리고 5초 후에 hello again!!
차이점은 greeting렌더링을 setState에서 하는 거야
state를 변경할 수 있고 자동으로 render()가 작동되는 거지
state를 바꿀때는 setState를 설정하고, 업데이트 할때마다 render()가 작동, 새로운 state와 함께

# 8. Practicing this setState
state를 좀더 연습
컴포넌트 외부에 있는 무비리스트를 state안으로 옮겨보자
```js
state = {
    movies: [
        {
            title: 'Thor: Ragnarok',
            poster: 'http://movie.phinf.naver.net/20170928_85/1506564710105ua5fS_PNG/movie_image.jpg?type=m203_290_2'
        },
        {
            title: 'THE OUTLAWS',
            poster: 'http://movie.phinf.naver.net/20170915_299/1505458505658vbKcN_JPEG/movie_image.jpg?type=m203_290_2'
        },
        {
            title: 'Geostorm',
            poster: 'http://movie2.phinf.naver.net/20170922_133/1506059018478U7ur6_JPEG/movie_image.jpg?type=m203_290_2'
        }
    ]
}

<div className="App">
    {this.state.movies.map((movie, index) => {
        return <Movie title={movie.title} poster={movie.poster} key={index} />
    })}
</div>
```
여기 영화리스트에서 영화를 하나 더 추가 하고싶으면 어떻게 할까
state안에 영화를 추가 하고 싶다고 써야함
컴포넌트가 mount하면 페이지로드 후 1초후에 추가한 새로운 영화가 보여짐
```js
componentDidMount() {
    setTimeout(() => {
        this.setState({
            movies: [
                ...this.state.movies, 
                {
                    title: 'The Bros, 2017',
                    poster: 'http://movie.phinf.naver.net/20170919_62/1505782593457htVeC_JPEG/movie_image.jpg?type=m203_290_2'
                }
            ]
        });
    }, 1000);
}
```
이전 영화 리스트를 그대로 두고 한개의 영화를 추가
우리는 전체 리스트를 대체하는 것이 아니라 한개만 추가
```js
movies: [
    ...this.state.movies, //이 코드를 삽입해서 이전 영화리스트를 그대로 두고 한개의 영화만 추가
    {
        title: 'The Bros, 2017',
        poster: 'http://movie.phinf.naver.net/20170919_62/1505782593457htVeC_JPEG/movie_image.jpg?type=m203_290_2'
    }
]
```
state를 활용 응용해서 다양한 효과를 볼 수 있음. 인피니티스크롤 동일한 효과 20개의 영화가 더 추가 로딩
끝까지 스크롤하면 20개의 영화를 추가하면 됨
계속 추가 컨텐츠를 밑에 로딩
```js
movies: [
    {
        title: 'The Bros, 2017',
        poster: 'http://movie.phinf.naver.net/20170919_62/1505782593457htVeC_JPEG/movie_image.jpg?type=m203_290_2'
    },
    ...this.state.movies
]
```
만약 ...this.state.movies 새로 추가하는 영화 다음에 입력하면 어떻게 될까?
영화 리스트 그 전에 새로운 영화가 출력


# 9. Loading states
이번에는 Loading states에 대해서 이야기 해보자
데이터가 없을때 로딩을 띄우고 있으면 영화정보가 보이도록

```js
render() {
    return (
        <div className="App">
            {this.state.movies ? this._renderMovies() : 'Loading'}
        </div>
    );
}
```
# 10. Smart vs Dumb Components
클래스기반 컴포넌트와 함수형 컴포넌트의 차이

스테이트의 개념을 사용할 때 클래스를 이용
단순한 컴포넌트로 여러개의 프로퍼티와 정적 JSX를 반환 (가볍고 무척 빠르고 쉽다)


함수로 이루어졌기에 함수형 컴포넌트라고 불림
한 함수가 JSX형태를 반환. 이는 결국 DOM렌더링 그게 다 매우 단순하다


새로운 컴포넌트를 작성하기 전에 자신에게 물어봐야할 질문
이 컴포넌트가 어떤 스테이트든 유지할 필요가 있느냐?

클래스 컴포넌트 
내부적은 정보를 저장하려할때 사용
보다 복합적이고 똑똑한 컴포넌트로 만들기 위해서
사용자가 input에 타이핑을 할때 이 컴포넌트는 다름 컴포넌트에 몇 가지 정보를 알려야 합니다.
예를 들어 사용자가 입력창에 뭔가를 타이핑하고 있어, 타이핑 하는 내용은 이거야
이를 위해 더나은 기능이 필요 클래스 기반의 컴포넌트라는 것을 생성 ES6를 사용해서 만듬

```js
import React from 'react';
class MoviePoster extends React.Component {}
```

React.Component로부터 모든기능을 제공 받으라는 것
다른말로 이 무비포스터는 React.Component클래스에게 받은 기능을 제공한다는 것
메소드 기반의 클래스를 사용. 여전히 그 자체로 렌더링 할 수 있는 능력이 필요
이를 위해 render() 메소드라는 것을 정의

Syntactic sugar
```js
import React, { Component } from 'react';
//{}괄호의 의미는 리액트 라이브러리를 불러와 Component라 부르는 변수를 프로퍼티 형태로 가져오라는 것
//const Component = React.Component; 이렇게 쓰는것과 같은 방식

class MoviePoster extends Component {}
```

class 컴포넌트는 state를 사용할 수 있음
functional컴포넌트는 props만 존재

모든 컴포넌트가 state 있는것은 아님
어떤 컴포넌트는 state없는 stateless functional 컴포넌트
state없고 props밖에 없을때

class 컴포넌트를 쓰는 대신에 functional컴포넌트로 변경
```js
//Movie.js

/*
class MoviePoster extends Component {
  static propTypes = {
    poster: PropTypes.string.isRequired
  }

  render() {
    return (
        <img src={this.props.poster} alt="" />
    );
  }
}
*/

//이전보다 적은양의 코드만 작성
function MoviePoster({poster}) {
  return (
     <img src={poster} alt="" />
  )
}

MoviePoster.propTypes = {
  poster: PropTypes.string.isRequired
}
```

# 11. AJAX on React

Fetch request
```js
componentDidMount() {
    console.log(fetch('https://yts.ag/api/v2/list_movies.json?sort_by=rating'))
}

Promise {[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined}
```
# 12. Promises
 영화 api 작업이 끝나야 애니메이션 api를 불러올 수 있음
 fetch, promises가 좋은 이유는 시나리오가 생기고 이를 관리할 수 있음
 Promises는 너가 성공적으로 수행할 수있고 그렇지 않을 경우 결과물을 catch, then으로 받아 볼 수 있음 

```js
    fetch('https://yts.ag/api/v2/list_movies.json?sort_by=rating')
    .then(response => response.json())
    .then(json => console.log(json))
    .catch(err => console.log(err))
```
then() response 살펴보기
* body: ReadableStream //이 뜻은 바이트(010101..)로 이루어져있다는 뜻, 이걸 json으로 변경 
.then(response => response.json())
* bodyUsed: false //아직 사용하지 않음

# 13. Async Await
이런 방식은 세련되지 않음. 그리고 애플리케이션이 커지면 then 안에 then으로 이어지면서 call back hell이라는  것에 빠짐
뭐 아는 사람들은 다 알거야 then then then 많아져서 길을 잃어버리는 거지

```js
fetch('https://yts.ag/api/v2/list_movies.json?sort_by=rating')
.then(response => response.json())
.then(json => {
    this.setState({
        movies: json.data.movies
    })
    .then(() => then())
    CALL HELL!!
})
.catch(err => console.log(err))
```
그래서 async await라는 것을 사용
새로운 function을 만들거야 _callApi, _getMovies

```js
componentDidMount() {
    this._getMovies()
}
_callApi = () => {
    fetch('https://yts.ag/api/v2/list_movies.json?sort_by=rating')
    .then(response => response.json())
    .then(json => console.log(json))
    .catch(err => console.log(err))
}
_getMovies = () => {

}
```
왜 이렇게 쓰느냐 
큰 컴포넌트 did mount갖고 싶지 않아 
사이즈가 크면 좋은 코딩방법이 아니야 왜냐면 많은 function을 불러올건데
다 한 군데 몰아있는 것보다 작은 function들이 각기 다른 장소에 있는 것이 좋음

async(동기): 이전 라인의 작업이 끝날 때까지 기다리는 것이 아닐때
이전 작업이 끝나야 그 다음 작업이 시작하는 형태가 아니야, 순서와 상관없이 작업이 진행 
function getMovies는 asynchronous function이라고 할 수 있어
이 안에 await이라고 쓸거야 

await: _callApi기능이 끝나는것을 기다리고 '끝나기를' 기다리는 거임('성공적으로 수행'이 아니라)
_callApi의 return value가 그것이 무엇이든
_callApi의 return value를 movies에 set할거야 
그리고 이 컴포넌트의 setState을 movies로 할거야 그건  _callApi의 value
```js
_getMovies = () => {
    const movies = await this._callApi();
    //이 부분 setState는 _callApi작업이 되기 전까지 실행되지 않음, '작업이 완료'되기 전까지 '성공적 수행'이 아니라
    //성공적 실패로 끝날 수 있어, 하지만 작업이 완료 되어야 해
    this.setState({
        movies
    })
}
```
이를 하는 방법은 fetch라는 이름의 promise를 return 할꺼야
```js
_callApi = () => {
    return fetch('https://yts.ag/api/v2/list_movies.json?sort_by=rating')
    .then(response => response.json())
    .then(json => json.data.movies)
    .catch(err => console.log(err))
}
```

key는 영화의 id를 사용해도 됨
왜 id를 사용하느냐?
컴포넌트의 키는 index를 사용하는것은 좋지 않음. 느림
```js
//before
_renderMovies = () => {
    return this.state.movies.map((movie, index) => {
        return <Movie title={movie.title} poster={movie.poster} key={index} />
    })
}

//after
_renderMovies = () => {
    return this.state.movies.map((movie) => {
        return <Movie title={movie.title} poster={movie.large_cover_image} key={id} />
    })
}
```

# 14. Updating Movie : Component
디자인에서 보듯이 포스터, 제목, 장르, 평점, 설명 등의 데이터가 필요. 데이터 확인 후 추가
```js
<Movie 
    title={movie.title_english}
    poster={movie.medium_cover_image}
    genres={movie.genres}
    synopsis={movie.synopsis}
    key={movie.id}
/>
```
이제 우리의 movie.js 컴포넌트의 props를 업데이트
prop type다음에 장르, 시놉시스를 추가하자
```js
Movie.propTypes = {
  title: PropTypes.string.isRequired,
  poster: PropTypes.string.isRequired,
  genres: PropTypes.array.isRequired,
  synopsis: PropTypes.string.isRequired
}
```
이제 html을 좀 더 예쁘게 써보자

className는 정상적인 css에서 class를 뜻 함
하지만, JSX에서는 className이라고 써야함

만약, 그냥 class라고 쓰면? 리액트가 알려줄거야
그러니 돌아가서 className라고 변경하고

이 className라고 쓰는 것은 여기에 있는 다른 키워드 class나 
클래스 기반 컴포넌트와 이름이 혼동되기 때문에

```js
//movie.js
function Movie({title, poster}){
  return (
      <div className="Movie">
          <div className="Movie__Columns"></div>
            <MoviePoster poster={poster} />
            <h1>{title}</h1>
      </div>
  );
}
```

그다음 2개의 컬럼이 필요해
className="Movie__Columns" 왜 이렇게 클래스 이름을 짓는지 모르겠으면 참고

다음엔 타이틀 div, Movie__Genres 라는 클래스 이름으로
그 다음은 MovieGenre 라는 새로운 functional 컴포넌트를 만들자

무비 컴포넌트에 장르, 시놉시스를 추가
```js
function Movie({title, poster, genres, synopsis}){
  return (
      <div className="Movie">
          <div className="Movie__Columns">
            <MoviePoster poster={poster} alt={title} />
          </div>

          <div className="Movie__Columns">
            
            <h1>{title}</h1>
            <div className="Movie__Genres">
              {genres.map((genre, index) => <MovieGenre genre={genre} key={index} />)}
            </div>
            <p className="Movie__Synopsis">{synopsis}</p>
          </div>
            

      </div>
  );
}
```
MoviePoster에 alt값 추가
alt는 타이틀 이라고 하자
```js
function MoviePoster({poster, alt}) {
  return (
     <img src={poster} alt={alt} title={alt} className="Movie__Poster" />
  )
}

MoviePoster.propTypes = {
  poster: PropTypes.string.isRequired,
  alt: PropTypes.string.isRequired
}
```

정리
내가 한것은 props를 더 추가 한거야
장르와, 시놉시스와 같은 이전에는 포스터와 타이틀 밖에 없었지
props를 더 추가하고 Movie컴포넌트에 등록했지
그다음 기본html을 작업했어 클래스명 추가 JSX, 컬럼 Movie포스터를 만들고 제목 만들고, 장르 array를 맵핑하고 무비 시놉시스 클래스를 만들었지
그리고 alt이미지를 만들었어
그리고 장르를 맵핑할때 MovieGenre라는 새로운 컴포넌트를 만들었어 functional컴포넌트로 간단한 span을 return하게 끔
그냥 span을 쓸 수도 있지만 별도로 컴포넌트를 생성한 이유는 이게 더 세련된 코딩방식이기 때문에
모든걸 컴포넌트로 쪼개고 작게 만드는것이 더 세련됨
이제 이 정보들을 이쁜 css에 담으면 됨
# 15. CSS for Movie

# 16. Building for Production 깃허브 페이지 배포
깃허브 페이지 gh-pages는 코드를 실행하고 웹사이트를 봄
```bash
$ npm run build
```
이건 css를 가져다가 압축 그리고 이를 build라는 public폴더에 넣을 꺼야 
우리가 로컬호스트에 있을때 사용하는 코드는 압축되어있지 않고 느리고 최적화 되어 있지 않았지
build작업을 하면 좀 더 최적화 되고 압축 더 향상 되는것이지

그리고 터미널의 메세지 확인
The project was built assuming it is hosted at the server root.
To override this, specify the homepage in your package.json.
For example, add this to build it for GitHub Pages:
"homepage" : "http://myname.github.io/myapp",

바로 이작업을 우리가 할 꺼야
package.json으로 가서 홈페이지 key를 추가 저장하고 다시 빌드
"homepage": "http://hohoya33.github.io/my-app"


# gh-pages Branch
github 접속 Create a new repository 
Repository name 입력
Initialize this repository with a README 체크

Branch:master 버튼 클릭
gh-pages 추가

Setting > Branches > Default branch gh-pages선택 후 Update > I understand update...클릭
첫페이지 이동 후  > 상단 branch클릭 > master 브랜치 삭제

* git 생성
$ git init
$ git remote add origin https://github.com/hohoya33/my-app.git


다시 메세지 확인
```bash
$ npm install --save-dev gh-pages
```

gh-pages 설치 후 아래 스크립트를 package.json에 추가
 // ...
"scripts": {
    // ...
    "predeploy": "npm run build",
    "deploy": "gh-pages -d build"



```bash
$ npm run deploy
```
 유저명, 비번 입력
 깃허브 페이지 확인




만약 이와 같은 구문에러를 만나면 npm start를 통해 무엇이 잘못되었는지 정확히 짚어줄것입니다.

this.setState({ videos: videos });
ES6로 이부분을 보다 압축 시킬 수 있습니다. key, value가 있을 때

this.setState({ videos }); 
이와 같은 형태로 변형되어 인식
이는 약간의 신텍스 슈가로 우리의 코드를 정리하기 위한 것. 오직 키와 변수 이름이 같을때 동작
이와 같은 고급 구문이 리액트에서 자주 사용, 일반적으로 이것이 혼란스럽게 보여도 이를 익숙해지려고 노력해보면서 
코드를 장기적으로 정리하는 연습을 길들이길 권합니다.


여기 재미있는 부분이 있는데요.
app은 비디오 리스트의 부모이고 비디오 리스트는 app 스테이트의 videos를 접근이 가능합니다.
비디오 리스트의 참조가 필요
기본적으로 부모 컴포넌트인 app에서 자식 컴포넌트인 비디오 리스트로 데이터를 전달해야 하는데 
부모컴포넌트로 부터 데이터를 자식 컴포넌트인 비디오 리스트로 전달하는것은 매우 간단 명료합니다.
비디오 리스트의 JSX 태그 위에 프로퍼티를 정의하면 되는데 이와같이 videos는 자바스크립트 변수를 참조하게 해야하는데
<VideoList videos={this.state.videos} />
괄호를 사용해서 this.state.videos를 작성. 이 데이터를 전달하는 것은 리액트의 props을 참조하게 되는데 

함수형 컴포넌트를 사용하면 이 props의 오브젝트는 함수의 요소로 들어갑니다.
const VideoList = (props) => {
    const videos = props.videos;
}
예를 들어 여기에 props.videos 처럼 정의해서 데이터를 가져올 수 있음

클래스 기반의 컴포넌트의 props는 어느 메소드에서 this.props를 정의해서 사용할 수 있움
즉 렌더링 메소드 안에 this.props가 그 자체나 부모 컴포넌트에 의해 어떤 프로퍼티 형태로 전달 받을 수 있는 것이죠
함수형 기반 컴포넌트를 클래스 기반 컴포넌트로 리팩토링할 때 알아야 할 중요한 것은 이 props를 this.props로 바꿔야 한다는 것입니다.


const VideoList = ({videos}) => { 
    //여기 {videos}는 아래 코드와 동일 줄여서 표현
    //const videos = props.videos;
    요소의 첫번째 객체가 비디오 프로퍼티로 나타나게 되고 비디오를 가져와 새로운 비디오나 새로운 변수를 생성하라는 의미
}


const url = 'https://www.youtube.com/embed/' + videoId;
우리는 이 문자열을 연결 혹은 템플릿 문자열이라 부를건데
ES6에서 하나의 문자열을 연결하거나 접선시킬때 보다 나은 구문으로 변경 시킬 수 있는데요
두개의 따옴표를 지우고 이를 백틱 문자열로 둘러쌉니다. 키보드 상단의 맨 왼쪽
여기안에 $달러 구문을 넣고 중괄호안에 비디오 아이디를 넣습니다. 
const url = `https://www.youtube.com/embed/${videoId}`;
단순히 두개의 문자열을 연결하는 것보다 읽기 좋다고 할 수있습니다.


비디오 리스트를 가져오기 위해 리퀘스트를 요청, video프로퍼티는 undefined를 VideoDetail에게 보냄
그래서 VideoDetail컴포넌트가 렌더링을 시도하기 전에 비디오가 props에 주어졌는지 확인하는 과정
우리는 비디오 프로퍼티가 있는지 컴포넌트를 렌더링하기 전에 
상단에 체크사항 추가
로딩을 반환 하도록 합니다.

if(!videos) {
    return <div>Loding...</div>
}


# 탑레벨 컴포넌트에서 자식컴포넌트에 콜백함수 이벤트 전달 
이와같은 콜백은 부모컴포넌트부터 자식컴포넌트들로 전달
부모컴포넌트와 자식컴포넌트가 소통하기 위한 훌륭한 방법
이렇게 두 레벨 이상으로 넘어가는것은 약간 드문 일(일반적으로 두 단계 넘어가는것은 복잡함)
```js
//index.js 탑레벨 컴포넌트
class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            videos: [],
            selectedVideo: null
        };

        YTSearch({key: API_KEY, term: 'surfboards'}, (videos) => {
            this.setState({
                videos: videos,
                selectedVideo: videos[0]
            });
        });

    }
    render(){
        return (
            <div>
                <SearcheBar />
                <VideoDetail video={ this.state.selectedVideo } />
                <VideoList 
                    onVideoSelect={ selectVideo => this.setState({selectedVideo}) } 
                    //이 함수는 하나의 목적을 가지고 있죠, 스테이트를 업데이트 
                    //비디오를 가져와서 선택한 비디오를 업데이트 합니다.
                    //이 프로퍼티를 비디오 리스트로 전달
                    videos={ this.state.videos }
                />
            </div>
        );
    }
}

//video_list.js
const VideoList = (props) => {
    const videoItems = props.videos.map((video) => {
        return (
            <VideoListItem
                onVideoSelect={props.onVideoSelect}
                //비디오 리스트는 프로퍼티를 가져와 비디오 리스트 아이템에 전달합니다.
                key={video.etag}
                video={video}
            />
        );
    });

    return (
        <ul>{videoItems}</ul>
    );
}

//video_list_item.js
const VideoListItem = ({video, onVideoSelect}) = > {
    return(
        <li onClick={() => onVideoSelect(video)}></li>
        //이 프로퍼티는 클릭할때마다 전달한 함수를 호출 합니다.
        //각 비디오 리스트 아이템은 다른 비디오를 가지고 있기 때문에 해당 비디오를 보게 됩니다.
    );
}

```







# 비디오 검색
```js
//index.js 탑레벨 컴포넌트
class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            videos: [],
            selectedVideo: null
        };

        this.videoSearch('surfboards');
    }
    //이 메소드안에 검색 메커니즘을 넣었는데요
    videoSearch(term){
        YTSearch({key: API_KEY, term: term}, (videos) => {
            this.setState({
                videos: videos,
                selectedVideo: videos[0]
            });
        });
    }
    render(){
        return(
            <div>
                <SearcheBar onSearchTermChange={ term => this.videoSearch(term) } />
                //이 의미는 이를 검색바 컴포넌트에 넘길 수 있다는 거죠
                //이 검색바가 검색어가 바뀌면 이를 term과 함께 videosSearch에 전달하여 호출

                <VideoDetail video={ this.state.selectedVideo } />
                <VideoList 
                    onVideoSelect={ selectVideo => this.setState({selectedVideo}) } 
                    videos={ this.state.videos }
                />
            </div>
        );
    }
}

//search_bar.js
class SearchBar extends Component {
    constructor(props){
        super(props);
        this.state = { term: '' };
    }
    onInputChange(term){
        this.setState({term});
        this.props.onSearchTermChange(term);
        //검색어가 새 검색어로 바뀔때 이를 호출
    }
    render(){
        return(
            <div className="search-bar">
                <input 
                    value={ this.state.term }
                    onChange={ event => this.onInputChange(event.target.value) }
                />
            </div>
        );
    }
}
```

# 인풋 검색어 조절 lodash
lodash라 불리는 함수 라이브러리를 이용. 많은 유틸리티 메소드가 있는데 그 중 하나는 debounce입니다.
이는 함수호출 시기를 조절 할 수 있지요.
첫번째로 해야할 일은 lodash를 설치
npm을 사용해서 따로 라이브러리를 설치 할게요. 터미널에서 이런식으로 작성합니다.
```bash
$ npm install --save lodash
```

이제 상단에 lodash를 가져올 것인데요 lodash라고 적기보다 _라고 정의할게요
이제 이를 어떻게 처리할지 이야기 해보겠습니다. 
```js
//index.js 탑레벨 컴포넌트
import _ from 'lodash';

class App extends Component {
    ...
    render(){
        const videoSearch = _.debounce((term) => { this.videoSearch(term) }, 300);
        //이는 효과적으로 새 검색을 매 300밀리초 마다 호출 사켜라는 의미
        //너무 자주 검색이 되지 않게하는 것이죠
        return(
            <div>
                <SearcheBar onSearchTermChange={ videoSearch } />
                <VideoDetail video={ this.state.selectedVideo } />
                <VideoList 
                    onVideoSelect={ selectVideo => this.setState({selectedVideo}) } 
                    videos={ this.state.videos }
                />
            </div>
        );
    }
}
```

# 리액트 마무리
어떻게 리액트가 동작하는지 이해했으면 여기 주의를 기울여야할 여러가지 컨셉을 요약해 보겠습니다.
첫번째로 클래스기반 컴포넌트와 함수형 컴포넌트의 차이
다음에 이야기 할것은 스테이트인데요, 이는 무척 까다로운 개념입니다.
클래스를 생성하는 것은 스테이트를 초기화 하는데 깔끔한 작업방법. 왜냐하면 스테이트를 초기화 할때 연관된 메소드가 있는데요
클래스 기반 컴포넌트에서는 constructor안에서 스테이트를 세팅합니다. 
this.state구문을 쓴것과 반대로 다른곳에서 this.setState를 작성하면 약간 혼란스럽죠
또하나 스테이트에대해 알아야 할것은 이 스테이트가 바뀔때마다 즉시 렌더링 되고 이 컴포넌트를 가지는 자식에게도 영향을 미칩니다.

마지막으로 기억해야할 것은 불러오기 구문과 내보내기 구문
인덱스 파일에는 여러 임폴트 구문이 있는데 컴포넌트 디렉토리로 부터 파일을 불러오죠
이 파일을 불러올때마다 상대경로로 작성, 반면에 라이브러리를 사용하려면 라이브러리의 이름을 넣습니다.








%PUBLIC_URL%
const envPublicUrl = process.env.PUBLIC_URL;


```bash

```

```js
//------ App.js ------

```

### XHR (AJAX) Requests
```bash
npm i axios --save-dev
```

